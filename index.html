<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>StudyQuest</title>

    <meta name="theme-color" content="#f3f4f6" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#111827" media="(prefers-color-scheme: dark)">

    <style>
        /* 1. htmlとbodyに最初から背景色をつける (これが白飛び防止の鍵) */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #f3f4f6; /* gray-100 (ライトモードの背景) */
        }

        /* 2. スプラッシュスクリーンの設定 */
        #splash-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #f3f4f6; /* 本体と同じ色 */
            transition: opacity 0.5s ease;
        }
        
        #splash-screen img {
            width: 16rem;
            height: 16rem;
            object-fit: contain;
            margin-bottom: 1rem;
        }

        /* ロゴの出し分け */
        #splash-logo-dark { display: none; }
        #splash-logo-light { display: block; }

        /* 3. ダークモード時の背景色をOS設定から即座に反映 */
        @media (prefers-color-scheme: dark) {
            html, body, #splash-screen {
                background-color: #111827; /* gray-900 (ダークモードの背景) */
            }
            #splash-logo-light { display: none; }
            #splash-logo-dark { display: block; }
        }

        /* クラスによる制御 (JSロード後) */
        html.dark, html.dark body, html.dark #splash-screen { background-color: #111827; }
        html.dark #splash-logo-light { display: none; }
        html.dark #splash-logo-dark { display: block; }
    </style>

    <script>
        // 画面描画前にOSの設定を確認して dark クラスを付与
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
    </script>

    <!-- PWA関連 -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="StudyQuest">

    <link rel="icon" type="image/png" href="SQ_logo.png">

    <link rel="apple-touch-icon" href="SQ_logo.png">

    <meta property="og:image" content="SQ_logo.png">
    
    <link rel="manifest" href="manifest.json">
    
    <!-- 外部ライブラリとフォント -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class' // ここでダークモードの制御方法を'class'に指定します
      }
    </script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <style>
        /* ▼▼▼ 追加: LINE Seed JP フォントの読み込み ▼▼▼ */
        @font-face {
            font-family: 'LINE Seed JP';
            src: url('LINESeedJP_OTF_Rg.woff2') format('woff2'); /* ファイル名を合わせる */
            font-weight: 400; /* 通常 */
            font-style: normal;
        }
        @font-face {
            font-family: 'LINE Seed JP';
            src: url('LINESeedJP_OTF_Bd.woff2') format('woff2'); /* ファイル名を合わせる */
            font-weight: 700; /* 太字 */
            font-style: normal;
        }
        /* ▲▲▲ 追加ここまで ▲▲▲ */

        :root {
            --primary-color: #4f46e5;
            --primary-color-hover: #4338ca;
        }
        /* ▼▼▼ 修正: font-family の先頭に 'LINE Seed JP' を追加 ▼▼▼ */
        body { 
            font-family: 'LINE Seed JP', 'Inter', 'Noto Sans JP', sans-serif; 
            -webkit-tap-highlight-color: transparent; 
        }
        .page { display: none; }
        .page.active { display: block; }
        #focus-page.page.active { display: flex; }
        #focus-page { display: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fadeIn {
            animation: fadeIn 0.8s ease-out forwards;
        }
        #loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid var(--primary-color); width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .primary-bg { background-color: var(--primary-color); }
        .primary-bg-hover:hover { background-color: var(--primary-color-hover); }
        .primary-text { color: var(--primary-color); }
        .toggle-checkbox { appearance: none; width: 40px; height: 20px; background: #ccc; border-radius: 20px; position: relative; cursor: pointer; transition: background .3s; }
        .toggle-checkbox:before { content: ''; position: absolute; width: 16px; height: 16px; background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform .3s; }
        .toggle-checkbox:checked { background: var(--primary-color); }
        .toggle-checkbox:checked:before { transform: translateX(20px); }
        #theme-purchase-modal, #background-purchase-modal { z-index: 60; }

        /* ミニタイマー */
        #mini-timer-container {
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s;
            transform: translateY(150%);
            opacity: 0;
            pointer-events: none;
        }
        #mini-timer-container.visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        #mini-timer-progress-bar {
            transition: width 0.5s linear;
        }
        /* 集中モード背景 */
        .focus-view-bg {
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
        }
        
        #app-container {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        .break-icon-grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); 
            gap: 0.5rem; 
            width: 100%;
        }

        .break-content-btn {
            background-color: rgba(255, 255, 255, 0.1);
            color: #edfcff;
            padding: 0.75rem; /* 👈 16px から 12px に変更 */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center; /* 👈 flex-start から center に変更 (最重要) */
            justify-content: flex-start; /* 👈 center から flex-start に変更 (上から配置) */
            /* font-weight: bold; */ /* 👈 この行は削除（span側で指定） */
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 100%;
            /* 高さを均一にするため (任意) */
            min-height: 100px;
        }
        .break-content-btn span {
            font-size: 0.75rem; /* 12px */
            font-weight: bold;
            line-height: 1.1;
            text-align: center;
            word-break: break-word; /* 英語などがはみ出た場合に備える */
        }
        .break-content-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        .sortable-ghost {
            opacity: 0.4;
            background-color: #e2e8f0; /* light gray */
        }
        .dark .sortable-ghost {
            background-color: #374151; /* dark gray */
        }
        .task-item .task-text-input {
            border-bottom: 1px solid transparent;
            transition: all 0.2s;
        }
        .task-item:hover .task-text-input {
            background-color: rgba(0,0,0,0.03);
        }
        .dark .task-item:hover .task-text-input {
            background-color: rgba(255,255,255,0.05);
        }
        /* 休憩設定モーダルのアイテム */
        .break-settings-item {
            display: flex;
            align-items: center;
            padding: 0.75rem; /* p-3 */
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb; /* text-gray-200 */
        }
        .break-settings-handle {
            cursor: move; /* "cursor-move" */
            margin-right: 0.75rem; /* mr-3 */
            color: #9ca3af; /* text-gray-400 */
        }
        .break-settings-item span {
            flex-grow: 1; /* "flex-grow" */
            text-align: left;
        }
        /* 1. ページ全体のテキスト選択を禁止 */
        body {
            -webkit-user-select: none; /* Safari/Chrome */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE */
            user-select: none;         /* 標準 */
        }
        
        /* 2. input や textarea は選択できるように許可する（コピペなどに必要） */
        input, 
        textarea {
            -webkit-user-select: text; /* Safari/Chrome */
            -moz-user-select: text;    /* Firefox */
            -ms-user-select: text;     /* IE */
            user-select: text;         /* 標準 */
        }
        
        /* 3. 画像やSVGアイコンの長押しメニュー（保存など）を禁止 (主にiOS) */
        img, svg {
            -webkit-touch-callout: none;
        }
        /* --- スワイプ機能用CSS --- */
        .swipe-container {
            position: relative;
            overflow: hidden; /* はみ出したボタンを隠す */
            touch-action: pan-y; /* 縦スクロールは許可しつつ、横操作をJSで制御 */
        }
        
        /* ボタンが配置される背景層 */
        .swipe-actions {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            display: flex;
            height: 100%;
            z-index: 1; /* コンテンツの下 */
        }
        
        .swipe-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 10px;
            height: 100%;
            border: none;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        
        /* コンテンツ層（指で動かす部分） */
        .swipe-content {
            position: relative;
            z-index: 10;
            background-color: inherit; /* 親の色を引き継ぐ */
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); /* 離した時のスナップアニメーション */
            will-change: transform; /* パフォーマンス最適化 */
        }
        
        /* ドラッグ中はアニメーションを切る（追従性を良くするため） */
        .is-dragging .swipe-content {
            transition: none;
        }
        
        /* 削除時のアニメーション */
        .swipe-deleting {
            transition: height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
            opacity: 0;
            margin: 0 !important;
            overflow: hidden;
        }
        /* 並び替えハンドル周辺のタッチ操作を確実にする */
        .task-handle, .quest-handle, .break-settings-handle {
            cursor: grab;
            touch-action: none; /* ブラウザ標準のスクロールなどを無効化し、JSで制御しやすくする */
            padding: 10px; /* タップ判定を大きくする */
            margin: -5px; /* レイアウト崩れ防止 */
        }
        
        /* INPUTタグはスワイプ対象外として、文字選択やカーソル移動を優先させる */
        input[type="text"], input[type="number"] {
            touch-action: manipulation; /* スワイプやズーム以外の標準動作 */
        }
        /* スワイプ中や、削除ボタンが出ている時は、ハンドルを操作不能にする（これで並び替え暴発を防ぐ） */
        .swipe-container.is-swiping .task-handle,
        .swipe-container.is-swiping .quest-handle,
        .swipe-container.is-swiping .break-settings-handle,
        .swipe-container.swiped-open .task-handle,
        .swipe-container.swiped-open .quest-handle,
        .swipe-container.swiped-open .break-settings-handle {
            pointer-events: none; /* タップ不可にする */
            opacity: 0.2; /* 視覚的にも無効であることを示す */
        }
        /* 既存の #iframe-overlay を修正（flexで中央揃えできるように） */
        #iframe-overlay {
            /* 既存のスタイルは維持しつつ、loaderの配置用にrelative等を調整 */
            z-index: 70; /* モーダルより上に来るように調整 */
        }
        
        /* iframe内のローダー（中央配置） */
        #iframe-loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: -1; /* iframeが読み込まれたら隠れるように後ろへ、あるいはJSで制御 */
        }
        
        /* ゲームプレビュー用の横スクロールコンテナ（スワイプ対応） */
        .preview-carousel {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden; 
            touch-action: pan-x;
            scroll-snap-type: x mandatory; /* スナップスクロール */
            -webkit-overflow-scrolling: touch;
            gap: 1rem;
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            height: 60vh;
        }
        
        .preview-item {
            flex: 0 0 100%; /* 1つで幅100%を使う */
            scroll-snap-align: center;
            width: 100%;
            height: 100%;
            border-radius: 0.5rem;
            background-color: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .preview-item img,
        .preview-item video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* アスペクト比を維持して収める */
        }
        .preview-item img {
            pointer-events: none;       /* タッチイベントを無効化（長押しメニュー防止） */
            -webkit-user-drag: none;    /* ドラッグ禁止 */
            user-select: none;          /* 選択禁止 */
        }
                
        /* 試聴ボタンのアニメーション */
        .playing-icon {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .focus-theme-border:focus {
            border-color: var(--primary-color) !important;
        }  
        
        /* ページコンテナ */
        main {
            position: relative;
            overflow-x: hidden; /* 横揺れ防止 */
        }

        /* アニメーション定義 (変化量を小さくして上品に) */
        @keyframes appZoomIn {
            0% { opacity: 0; transform: scale(0.98); } /* 0.92 -> 0.98 に変更 */
            100% { opacity: 1; transform: scale(1); }
        }
        @keyframes appZoomOut {
            0% { opacity: 0; transform: scale(1); }
            100% { opacity: 0; transform: scale(1); } /* 1.05 -> 1.02 に変更 */
        }

        /* 新しく入ってくるページ */
        .page-enter {
            display: block !important;
            animation: appZoomIn 0.25s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; /* 時間を少し短縮 */
            z-index: 20;
            will-change: transform, opacity; /* 【重要】描画最適化のヒント */
        }
        #focus-page.page-enter {
            display: flex !important;
        }

        /* 消えていくページ */
        .page-exit {
            display: block !important;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            animation: appZoomOut 0.25s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            z-index: 10;
            pointer-events: none;
            will-change: transform, opacity; /* 【重要】描画最適化のヒント */
        }
        #focus-page.page-exit {
            display: flex !important;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 overflow-hidden h-[100dvh] antialiased">

    <div id="splash-screen" class="fixed inset-0 z-[300] flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-900 transition-opacity duration-500">
        <img id="splash-logo-light" src="SQ_logo2.png" alt="StudyQuest Logo" class="w-64 h-64 mb-4 block dark:hidden">
        
        <img id="splash-logo-dark" src="SQ_logo3.png" alt="StudyQuest Logo Dark" class="w-64 h-64 mb-4 hidden dark:block">
    </div>

    <div id="app-container" class="h-full w-full flex flex-col max-w-lg mx-auto shadow-2xl">
        
        <header class="bg-white dark:bg-gray-800/80 backdrop-blur-sm z-30 p-4 flex items-center justify-between border-b border-gray-200 dark:border-gray-700 sticky top-0">
            <h1 id="header-title" class="text-xl font-bold text-gray-900 dark:text-white">ホーム</h1>
            <button id="lp-button" class="flex items-center space-x-2 bg-yellow-400/20 text-yellow-600 dark:text-yellow-400 rounded-full px-3 py-1 hover:bg-yellow-400/30 transition-colors">
                <i data-lucide="star" class="w-4 h-4 fill-current"></i>
                <span id="lp-display" class="font-bold text-sm">0 LP</span>
            </button>
        </header>

        <main class="flex-grow overflow-y-auto pb-20">
            <div id="home-page" class="page active p-4 space-y-6">
                <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow-sm text-center">
                    <p id="today-date" class="text-lg font-semibold text-gray-600 dark:text-gray-300"></p>
                </div>

                 <div>
                    <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center mb-3">
                        <i data-lucide="check-square" class="w-5 h-5 mr-2 primary-text"></i> 今日の予定
                    </h2>
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow-sm">
                        <div id="home-task-list" class="space-y-2">
                            <p class="text-center text-sm text-gray-500">今日の予定はありません。</p>
                        </div>
                        <div class="flex items-center space-x-2 mt-4 pt-3 border-t border-gray-200 dark:border-gray-600">
                            <span id="new-task-number" class="font-bold w-6 text-center text-gray-500 dark:text-gray-400">1</span>
                            <input type="text" id="new-task-input" placeholder="新しいタスクを追加 (Enterで確定)" class="flex-grow bg-transparent p-1 border-b-2 border-gray-300 dark:border-gray-600 focus-theme-border focus:outline-none transition-colors">
                        </div>
                    </div>
                </div>
                
                <div>
                    <div class="flex justify-between items-center mb-3">
                        <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center"><i data-lucide="calendar-clock" class="w-5 h-5 mr-2 primary-text"></i> カウントダウン</h2>
                        <button id="add-countdown-btn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-600"><i data-lucide="plus" class="w-5 h-5"></i></button>
                    </div>
                    <div id="countdown-list" class="space-y-3"></div>
                </div>
                
                 
            </div>

            <div id="study-page" class="page p-4">
                <div class="mb-6">
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 dark:text-gray-300 flex items-center"><i data-lucide="pin" class="w-5 h-5 mr-2 primary-text"></i> ピン留め</h2>
                    <div id="pinned-quizzes" class="grid grid-cols-1 gap-3"></div>
                </div>
                <div>
                    <h2 class="text-lg font-semibold mb-3 text-gray-700 dark:text-gray-300 flex items-center"><i data-lucide="book-marked" class="w-5 h-5 mr-2 primary-text"></i> すべてのクイズ</h2>
                    <div id="filter-container" class="flex space-x-2 mb-4 overflow-x-auto pb-2"></div>
                    <div id="all-quizzes" class="grid grid-cols-1 gap-3"></div>
                </div>
            </div>             
            <div id="focus-page" class="page relative flex flex-col h-full">
                
                <div id="focus-main-view" class="flex flex-col h-full p-4">
                    <div class="flex-shrink-0 mb-4 space-y-4">
                        <button id="show-quest-btn" class="w-full p-3 rounded-lg font-bold text-lg shadow-md flex items-center justify-center space-x-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors" data-mode="quest">
                            <i data-lucide="award" class="w-6 h-6"></i>
                            <span>クエスト</span>
                        </button>
                        
                        <div class="flex bg-gray-200 dark:bg-gray-700 rounded-lg p-1">
                            <button class="focus-mode-btn flex-1 p-2 rounded-md text-sm font-semibold" data-mode="timer">タイマー</button>
                            <button class="focus-mode-btn flex-1 p-2 rounded-md text-sm font-semibold" data-mode="stopwatch">ストップウォッチ</button>
                        </div>
                    </div>
            
                    <div id="timer-view" class="focus-view-bg flex-grow flex flex-col items-center justify-center text-center relative text-white rounded-lg">
                        <div class="absolute inset-0 bg-black/50 rounded-lg"></div>
                        <div class="relative z-10 p-4">
                            <div id="timer-settings-container">
                                <div class="flex items-center justify-center space-x-2 mb-6">
                                    <button class="time-add-btn bg-white/20 hover:bg-white/30 px-4 py-2 rounded-full" data-time="60">1分</button>
                                    <button class="time-add-btn bg-white/20 hover:bg-white/30 px-4 py-2 rounded-full" data-time="300">5分</button>
                                    <button class="time-add-btn bg-white/20 hover:bg-white/30 px-4 py-2 rounded-full" data-time="1800">30分</button>
                                    <button class="time-add-btn bg-white/20 hover:bg-white/30 px-4 py-2 rounded-full" data-time="3600">60分</button>
                                    <button id="timer-reset-btn" class="bg-white/20 hover:bg-white/30 w-10 h-10 rounded-full flex items-center justify-center">
                                        <i data-lucide="rotate-cw" class="w-5 h-5"></i>
                                    </button>
                                </div>
                            </div>
                            <div id="focus-timer-display" class="text-7xl font-bold tabular-nums mb-6">30:00</div>
                            <button id="focus-start-btn" class="primary-bg primary-bg-hover text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center mx-auto"><i data-lucide="play" class="w-6 h-6 mr-2"></i>スタート</button>
                            <div id="focus-controls" class="hidden flex flex-wrap items-center justify-center gap-4">
                                <button id="focus-pause-btn" class="bg-gray-500/70 hover:bg-gray-600/70 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center"><i data-lucide="pause" class="w-6 h-6 mr-2"></i>一時停止</button>
                                <button id="focus-end-btn" class="bg-red-500/70 hover:bg-red-600/70 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center"><i data-lucide="stop-circle" class="w-6 h-6 mr-2"></i>終了</button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="stopwatch-view" class="focus-view-bg hidden flex-grow flex-col items-center justify-center text-center relative text-white rounded-lg">
                        <div class="absolute inset-0 bg-black/50 rounded-lg"></div>
                        <div class="relative z-10 p-4">
                            <div id="stopwatch-display" class="text-7xl font-bold tabular-nums mb-6">00:00</div>
                            <button id="stopwatch-start-btn" class="primary-bg primary-bg-hover text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center mx-auto"><i data-lucide="play" class="w-6 h-6 mr-2"></i>スタート</button>
                            <div id="stopwatch-controls" class="hidden flex flex-wrap items-center justify-center gap-4">
                                <button id="stopwatch-pause-btn" class="bg-gray-500/70 hover:bg-gray-600/70 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center"><i data-lucide="pause" class="w-6 h-6 mr-2"></i>一時停止</button>
                                <button id="stopwatch-end-btn" class="bg-red-500/70 hover:bg-red-600/70 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg flex items-center"><i data-lucide="flag" class="w-6 h-6 mr-2"></i>記録して終了</button>
                            </div>
                        </div>
                    </div>
                </div>
            
                <div id="quest-view" class="hidden absolute inset-0 z-10 flex-col p-4">
                    
                    <div class="flex-shrink-0 flex items-center justify-between mb-4">
                        <button id="quest-back-btn" class="p-2 text-gray-600 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-full">
                            <i data-lucide="chevron-left" class="w-6 h-6"></i>
                        </button>
                        <h2 class="text-xl font-bold text-gray-900 dark:text-white">クエスト設定</h2>
                        <div class="w-10"></div> 
                    </div>
                    
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow-sm mb-4 flex-shrink-0">
                        <button id="load-tasks-btn" class="w-full mb-2 primary-bg primary-bg-hover text-white py-2 px-4 rounded-lg font-bold flex items-center justify-center space-x-2">
                            <i data-lucide="check-square" class="w-5 h-5"></i>
                            <span>「今日の予定」を読み込む</span>
                        </button>
                        <hr class="my-3 border-gray-200 dark:border-gray-600">
                        
                        <div class="flex items-center space-x-2 text-sm">
                            <input type="number" id="break-interval-input" value="2" class="w-16 p-1 border rounded dark:bg-gray-800 dark:border-gray-600">
                            <span>セクションごとに</span>
                            <input type="number" id="break-duration-input" value="5" class="w-16 p-1 border rounded dark:bg-gray-800 dark:border-gray-600">
                            <span>分休憩</span>
                        </div>
                        <button id="add-breaks-btn" class="mt-2 text-sm bg-gray-200 dark:bg-gray-600 px-3 py-1 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 transition">休憩を自動挿入</button>
                    </div>
                    
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow-sm flex-grow overflow-y-auto pb-36"> 
                        <div id="quest-plan-list" class="space-y-2">
                            </div>
                        
                        <div class="flex justify-between mt-4">
                            <button id="add-section-btn" class="text-sm bg-gray-200 dark:bg-gray-600 px-3 py-1 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 transition">セクション追加</button>
                            <button id="add-break-btn" class="text-sm bg-gray-200 dark:bg-gray-600 px-3 py-1 rounded-md hover:bg-gray-300 dark:hover:bg-gray-500 transition">休憩追加</button>
                        </div>
                    </div>
                    
                    <div class="fixed bottom-16 left-0 right-0 max-w-lg mx-auto p-4 z-20 pointer-events-none">
                        <button id="start-quest-btn" class="w-full primary-bg primary-bg-hover text-white py-3 px-4 rounded-lg font-bold text-lg shadow-md hover:scale-105 transition-transform transform flex items-center justify-center space-x-2 pointer-events-auto">
                            <i data-lucide="play" class="w-6 h-6"></i>
                            <span>クエストを開始する</span>
                        </button>
                    </div>
            
                </div>
            </div>
            <div id="my-chart-page" class="page p-4 space-y-6">
                <div class="grid grid-cols-3 gap-3">
                    <div class="bg-white dark:bg-gray-700 p-3 rounded-lg shadow text-center">
                        <p class="text-xs text-gray-500 dark:text-gray-400 mb-1">今日</p>
                        <p class="text-xl font-bold primary-text" id="report-stat-today">0<span class="text-xs text-gray-500 ml-1">時間</span></p>
                    </div>
                    <div class="bg-white dark:bg-gray-700 p-3 rounded-lg shadow text-center">
                        <p class="text-xs text-gray-500 dark:text-gray-400 mb-1">今週</p>
                        <p class="text-xl font-bold primary-text" id="report-stat-week">0<span class="text-xs text-gray-500 ml-1">時間</span></p>
                    </div>
                    <div class="bg-white dark:bg-gray-700 p-3 rounded-lg shadow text-center">
                        <p class="text-xs text-gray-500 dark:text-gray-400 mb-1">総合計</p>
                        <p class="text-xl font-bold primary-text" id="report-stat-total">0<span class="text-xs text-gray-500 ml-1">時間</span></p>
                    </div>
                </div>
            
                <div>
                    <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center mb-3">
                        <i data-lucide="bar-chart-3" class="w-5 h-5 mr-2 primary-text"></i> 週間レポート
                    </h2>
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow">
                        <canvas id="study-time-chart"></canvas>
                    </div>
                </div>
            
                <div class="flex flex-col h-[75vh]"> <h2 class="text-lg font-semibold text-gray-700 dark:text-gray-300 flex items-center mb-3">
                        <i data-lucide="calendar" class="w-5 h-5 mr-2 primary-text"></i> 学習ログ
                    </h2>
                    
                    <div class="bg-white dark:bg-gray-700 p-4 rounded-t-lg shadow-sm z-10">
                        <div class="flex justify-between items-center mb-4">
                            <button id="cal-prev-btn" class="p-1 hover:bg-gray-100 dark:hover:bg-gray-600 rounded"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                            <h3 id="cal-month-title" class="font-bold text-lg"></h3>
                            <button id="cal-next-btn" class="p-1 hover:bg-gray-100 dark:hover:bg-gray-600 rounded"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
                        </div>
                        <div class="grid grid-cols-7 gap-1 text-center text-xs mb-2 text-gray-400">
                            <span>日</span><span>月</span><span>火</span><span>水</span><span>木</span><span>金</span><span>土</span>
                        </div>
                        <div id="calendar-grid" class="grid grid-cols-7 gap-1 text-center text-sm">
                            </div>
                    </div>
            
                    <div class="bg-gray-50 dark:bg-gray-800 rounded-b-lg shadow p-4 flex-grow overflow-y-auto border-t border-gray-200 dark:border-gray-600">
                        <h4 id="detail-date-title" class="text-sm font-bold mb-3 text-gray-500 dark:text-gray-400 sticky top-0 bg-gray-50 dark:bg-gray-800 py-1">今日の詳細</h4>
                        <div id="study-session-list" class="space-y-3">
                            <p class="text-center text-xs text-gray-400 mt-4">記録がありません</p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="settings-page" class="page p-4 space-y-4">
                <div id="notification-settings-card" class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow">
                    <h3 class="font-semibold mb-2">通知設定</h3>
                    <button id="notification-permission-btn" class="w-full primary-bg primary-bg-hover text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center mb-4"><i data-lucide="bell-ring" class="w-5 h-5 mr-2"></i>ブラウザ通知を許可</button>
                </div>

                <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow">
                    <h3 class="font-semibold mb-2 flex items-center justify-between">
                        <span>BGM設定 (クエスト中)</span>
                        <div class="flex items-center">
                            <input type="checkbox" id="bgm-toggle" class="toggle-checkbox">
                        </div>
                    </h3>
                    <p class="text-xs text-gray-500 mb-4">ONにすると、クエストの「学習セクション」中に選択した曲がループ再生されます。</p>
                    
                    <h4 class="text-sm font-bold mb-2">プレイリスト</h4>
                    <div id="playlist-container" class="space-y-2 mb-4">
                        <p class="text-sm text-gray-400">曲がありません。LPで交換してください。</p>
                    </div>
                    
                    <h4 class="text-sm font-bold mb-2">交換済みの曲 (タップで追加)</h4>
                    <div id="unlocked-music-list" class="flex flex-wrap gap-2">
                        </div>
                </div>
                <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow">
                     <h3 class="font-semibold mb-2">テーマカラーを選択</h3>
                     <div id="theme-selector" class="grid grid-cols-4 gap-4"></div>
                </div>
                <div class="bg-white dark:bg-gray-700 p-4 rounded-lg shadow">
                    <h3 class="font-semibold mb-2">壁紙を選択</h3>
                    <div id="background-selector" class="grid grid-cols-3 gap-4"></div>
                    <hr class="my-4 border-gray-200 dark:border-gray-600">
                    <div class="flex items-center justify-between">
                        <p class="font-semibold">壁紙をアプリ全体に適用</p>
                        <input type="checkbox" id="background-scope-toggle" class="toggle-checkbox">
                    </div>
                </div>
            </div>
        </main>

        <div id="mini-timer-container" class="fixed bottom-20 left-0 right-0 max-w-lg mx-auto px-4 z-20">
             <div id="mini-timer-bar" class="w-full bg-gray-800/90 backdrop-blur-sm rounded-lg shadow-lg flex items-center p-2 space-x-3 cursor-pointer">
                <div class="flex items-center space-x-3 flex-grow min-w-0">
                    <i data-lucide="timer" class="w-5 h-5 primary-text flex-shrink-0"></i>
                    <span id="mini-timer-text" class="text-sm font-bold tabular-nums text-white truncate"></span>
                </div>
                <div class="w-1/3 h-1.5 bg-gray-600 rounded-full overflow-hidden flex-shrink-0">
                    <div id="mini-timer-progress-bar" class="h-full primary-bg rounded-full"></div>
                </div>
                <button id="close-mini-timer-btn" class="p-1 text-gray-400 hover:text-white flex-shrink-0">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
        </div>

        <nav class="fixed bottom-0 left-0 right-0 max-w-lg mx-auto h-16 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm border-t border-gray-200 dark:border-gray-700 flex justify-around items-center shadow-top z-20">
            <button class="tab-btn flex flex-col items-center justify-center w-full h-full primary-text" data-page="home-page" data-title="ホーム"><i data-lucide="home" class="w-6 h-6"></i><span class="text-xs mt-1">ホーム</span></button>
            <button class="tab-btn flex flex-col items-center justify-center w-full h-full text-gray-500" data-page="study-page" data-title="学習"><i data-lucide="book-marked" class="w-6 h-6"></i><span class="text-xs mt-1">学習</span></button>
            <button class="tab-btn flex flex-col items-center justify-center w-full h-full text-gray-500" data-page="focus-page" data-title="集中"><i data-lucide="timer" class="w-6 h-6"></i><span class="text-xs mt-1">集中</span></button>
            <button class="tab-btn flex flex-col items-center justify-center w-full h-full text-gray-500" data-page="my-chart-page" data-title="レポート"><i data-lucide="clipboard-list" class="w-6 h-6"></i><span class="text-xs mt-1">レポート</span></button>
            <button class="tab-btn flex flex-col items-center justify-center w-full h-full text-gray-500" data-page="settings-page" data-title="設定"><i data-lucide="settings" class="w-6 h-6"></i><span class="text-xs mt-1">設定</span></button>
        </nav>
    </div>

    <div id="welcome-screen" class="fixed inset-0 z-[200] bg-gray-100 dark:bg-gray-900 flex flex-col items-center justify-center p-6 hidden">
        <div class="mb-12 animate-fadeIn">
            <img src="SQ_logo4.png" alt="Welcome" class="w-80 h-80 object-contain mx-auto block dark:hidden">

            <img src="SQ_logo5.png" alt="Welcome Dark" class="w-80 h-80 object-contain mx-auto hidden dark:block">
        </div>

        <div class="w-full max-w-xs space-y-4 animate-fadeIn" style="animation-delay: 0.3s; opacity: 0;">
            <button id="btn-start-new" class="w-full primary-bg primary-bg-hover text-white font-bold py-4 rounded-xl shadow-lg transition-transform hover:scale-105">
                初めての方はこちら
            </button>
            <button id="btn-transfer-start" class="w-full bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 font-bold py-4 rounded-xl shadow transition-colors border border-gray-200 dark:border-gray-700">
                以前のデータを引き継ぐ
            </button>
        </div>
    </div>

    <div id="registration-screen" class="fixed inset-0 z-[200] bg-gray-100 dark:bg-gray-900 flex flex-col p-6 hidden">
        <header class="flex items-center mb-6">
            <button id="reg-back-btn" class="p-2 -ml-2"><i data-lucide="chevron-left" class="w-6 h-6"></i></button>
            <h2 class="text-xl font-bold ml-2">プロフィール設定</h2>
        </header>
        
        <div class="flex-grow flex flex-col items-center space-y-6 max-w-sm mx-auto w-full">
            <div class="text-center">
                <label class="block text-sm font-bold mb-2 text-gray-500">アイコン (絵文字)</label>
                <div class="relative inline-block">
                    <input type="text" id="reg-icon" class="w-24 h-24 text-center text-6xl border-2 border-dashed border-gray-300 rounded-full focus:outline-none focus:border-indigo-500 bg-white dark:bg-gray-800" value="🎓" readonly>
                    <div class="absolute -bottom-2 -right-2 bg-blue-500 text-white p-2 rounded-full shadow cursor-pointer" id="icon-picker-btn">
                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                    </div>
                </div>
                <p class="text-xs text-gray-400 mt-2">タップしてランダム変更</p>
            </div>

            <div class="w-full">
                <label class="block text-sm font-bold mb-2 text-gray-500">ユーザー名</label>
                <input type="text" id="reg-name" class="w-full p-4 rounded-xl border border-gray-200 dark:border-gray-700 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="例: スタディ勇者">
            </div>

            <div class="w-full">
                <label class="block text-sm font-bold mb-2 text-gray-500">学年</label>
                <div class="relative">
                    <select id="reg-grade" class="w-full p-4 rounded-xl border border-gray-200 dark:border-gray-700 dark:bg-gray-800 appearance-none focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <option value="" disabled selected>選択してください</option>
                        <option value="小学1年生">小学1年生</option>
                        <option value="小学2年生">小学2年生</option>
                        <option value="小学3年生">小学3年生</option>
                        <option value="小学4年生">小学4年生</option>
                        <option value="小学5年生">小学5年生</option>
                        <option value="小学6年生">小学6年生</option>
                        <option value="中学1年生">中学1年生</option>
                        <option value="中学2年生">中学2年生</option>
                        <option value="中学3年生">中学3年生</option>
                        <option value="高校1年生">高校1年生</option>
                        <option value="高校2年生">高校2年生</option>
                        <option value="高校3年生">高校3年生</option>
                        <option value="大学・専門学生">大学・専門学生</option>
                        <option value="社会人・その他">社会人・その他</option>
                    </select>
                    <i data-lucide="chevron-down" class="absolute right-4 top-1/2 -translate-y-1/2 text-gray-400 pointer-events-none"></i>
                </div>
            </div>
            
            <div class="flex-grow"></div>

            <button id="reg-complete-btn" class="w-full primary-bg primary-bg-hover text-white font-bold py-4 rounded-xl shadow-lg disabled:opacity-50 disabled:cursor-not-allowed">
                次へ進む
            </button>
        </div>
    </div>

    <div id="tutorial-screen" class="fixed inset-0 z-[200] bg-gray-900 text-white flex flex-col hidden">
        <div class="flex-grow relative overflow-hidden" id="tutorial-slider">
            <div class="flex transition-transform duration-300 h-full" id="tutorial-track">
                <div class="w-full h-full flex-shrink-0 flex flex-col items-center justify-center p-6 text-center">
                    <div class="w-full max-w-xs aspect-[9/16] bg-gray-800 rounded-lg mb-6 flex items-center justify-center border-2 border-gray-700">
                        <img src="tutorial_1.png" alt="Tutorial 1" class="w-full h-full object-contain" onerror="this.src='https://placehold.co/300x500/222/fff?text=Tutorial+1'">
                    </div>
                    <h3 class="text-2xl font-bold mb-2">クエストで学習</h3>
                    <p class="text-gray-400">ポモドーロタイマーを使って<br>集中して学習に取り組もう。</p>
                </div>
                <div class="w-full h-full flex-shrink-0 flex flex-col items-center justify-center p-6 text-center">
                    <div class="w-full max-w-xs aspect-[9/16] bg-gray-800 rounded-lg mb-6 flex items-center justify-center border-2 border-gray-700">
                         <img src="tutorial_2.png" alt="Tutorial 2" class="w-full h-full object-contain" onerror="this.src='https://placehold.co/300x500/222/fff?text=Tutorial+2'">
                    </div>
                    <h3 class="text-2xl font-bold mb-2">ポイントを貯める</h3>
                    <p class="text-gray-400">学習時間に応じてLPを獲得。<br>好きなアイテムと交換しよう。</p>
                </div>
                <div class="w-full h-full flex-shrink-0 flex flex-col items-center justify-center p-6 text-center">
                    <div class="w-full max-w-xs aspect-[9/16] bg-gray-800 rounded-lg mb-6 flex items-center justify-center border-2 border-gray-700">
                         <img src="tutorial_3.png" alt="Tutorial 3" class="w-full h-full object-contain" onerror="this.src='https://placehold.co/300x500/222/fff?text=Tutorial+3'">
                    </div>
                    <h3 class="text-2xl font-bold mb-2">準備完了！</h3>
                    <p class="text-gray-400">さあ、あなただけの<br>学習の旅を始めましょう。</p>
                </div>
            </div>
        </div>
        
        <div class="p-6 flex justify-between items-center">
            <div class="flex space-x-2" id="tutorial-dots">
                <span class="w-2 h-2 rounded-full bg-white"></span>
                <span class="w-2 h-2 rounded-full bg-gray-600"></span>
                <span class="w-2 h-2 rounded-full bg-gray-600"></span>
            </div>
            <button id="tutorial-next-btn" class="primary-bg px-6 py-2 rounded-full font-bold shadow-lg">次へ</button>
        </div>
    </div>

    <div id="migration-modal" class="fixed inset-0 z-[210] bg-black/90 text-white flex items-center justify-center p-4 hidden">
        <div class="w-full max-w-md bg-gray-800 rounded-xl p-6 relative">
            <button id="close-migration-btn" class="absolute top-4 right-4 text-gray-400 hover:text-white"><i data-lucide="x"></i></button>
            
            <h2 class="text-xl font-bold mb-4 flex items-center"><i data-lucide="smartphone" class="mr-2"></i> データ引き継ぎ</h2>
            
            <div id="migration-step-1" class="space-y-4">
                <p class="text-sm text-gray-300">古いスマホと新しいスマホを用意してください。</p>
                <div class="grid grid-cols-2 gap-4">
                    <button id="migration-mode-send" class="p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition flex flex-col items-center">
                        <i data-lucide="upload-cloud" class="w-8 h-8 mb-2 text-blue-400"></i>
                        <span class="font-bold">送る</span>
                        <span class="text-xs text-gray-400 mt-1">(古いスマホ)</span>
                    </button>
                    <button id="migration-mode-receive" class="p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition flex flex-col items-center">
                        <i data-lucide="download-cloud" class="w-8 h-8 mb-2 text-green-400"></i>
                        <span class="font-bold">受け取る</span>
                        <span class="text-xs text-gray-400 mt-1">(新しいスマホ)</span>
                    </button>
                </div>
            </div>

            <div id="migration-sender-view" class="hidden text-center space-y-4">
                <p class="text-sm">新しいスマホで「受け取る」を選択し、<br>表示されるIDを入力してください。</p>
                <div class="bg-black/50 p-4 rounded text-center">
                    <p class="text-xs text-gray-400 mb-1">相手のIDを入力:</p>
                    <input type="text" id="migration-target-id" class="bg-gray-700 text-white p-2 rounded w-full text-center font-mono text-lg tracking-widest uppercase" placeholder="相手のID">
                </div>
                <button id="migration-connect-btn" class="w-full primary-bg py-3 rounded-lg font-bold">データを送信</button>
                <p id="migration-status-send" class="text-xs text-yellow-400 h-4"></p>
            </div>

            <div id="migration-receiver-view" class="hidden text-center space-y-4">
                <p class="text-sm">このIDを古いスマホに入力してください。</p>
                <div class="bg-black/50 p-6 rounded text-center">
                    <p class="text-5xl font-mono font-bold tracking-widest text-green-400" id="migration-my-id">...</p>
                </div>
                <p class="text-xs text-gray-400 animate-pulse">接続待機中...</p>
                <p id="migration-status-receive" class="text-xs text-yellow-400"></p>
            </div>
        </div>
    </div>

    <div id="profile-modal" class="fixed inset-0 z-[60] bg-gray-100 dark:bg-gray-900 flex flex-col hidden">
         <header class="bg-white dark:bg-gray-800 p-4 flex items-center justify-between shadow-sm">
             <button class="close-profile-btn p-2"><i data-lucide="chevron-left" class="w-6 h-6"></i></button>
             <h2 class="font-bold">プロフィール編集</h2>
             <div class="w-8"></div>
         </header>
         <div class="p-6 flex flex-col items-center space-y-6">
             <div class="relative">
                 <input type="text" id="edit-profile-icon" class="w-24 h-24 text-center text-6xl border-2 border-dashed rounded-full bg-white dark:bg-gray-800" readonly>
                 <button id="edit-icon-random-btn" class="absolute bottom-0 right-0 bg-blue-500 text-white p-2 rounded-full"><i data-lucide="refresh-cw" class="w-4 h-4"></i></button>
             </div>
             <div class="w-full">
                 <label class="block text-sm font-bold mb-1">ユーザー名</label>
                 <input type="text" id="edit-profile-name" class="w-full p-3 rounded border dark:bg-gray-800 dark:border-gray-600">
             </div>
             <div class="w-full">
                 <label class="block text-sm font-bold mb-1">学年</label>
                 <select id="edit-profile-grade" class="w-full p-3 rounded border dark:bg-gray-800 dark:border-gray-600">
                    </select>
             </div>
             <button id="save-profile-btn" class="w-full primary-bg text-white py-3 rounded-xl font-bold mt-auto">保存する</button>

             <hr class="w-full border-gray-300 dark:border-gray-700 my-4">
             
             <button id="open-migration-menu-btn" class="w-full bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200 py-3 rounded-xl font-bold flex items-center justify-center">
                <i data-lucide="smartphone" class="w-5 h-5 mr-2"></i> データを引き継ぐ (機種変更)
             </button>
         </div>
    </div>

    <!-- ===== モーダル ===== -->
    <div id="quiz-modal" class="fixed inset-0 bg-black/70 z-50 flex-col hidden"><div class="w-full h-full max-w-lg mx-auto bg-gray-100 dark:bg-gray-900 flex flex-col"><header class="p-3 flex items-center justify-between shadow-md bg-white dark:bg-gray-800"><h2 id="quiz-modal-title" class="truncate font-bold"></h2><button class="close-modal-btn p-1" data-modal="quiz-modal"><i data-lucide="x"></i></button></header><div class="flex-grow relative"><div class="absolute inset-0 flex items-center justify-center"><div id="loader"></div></div><iframe id="quiz-iframe" class="w-full h-full border-0 invisible" sandbox="allow-scripts allow-forms allow-popups"></iframe></div></div></div>
    <div id="assessment-modal" class="fixed inset-0 bg-black/70 z-50 items-center justify-center hidden p-4">
            <div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
                <h2 class="text-xl font-bold mb-4">お疲れ様でした！</h2>
                <p class="mb-6">このクイズの理解度を記録しよう</p>
                <div class="flex justify-around">
                    <button class="assessment-btn p-2 w-24 flex flex-col items-center" data-level="3"><i data-lucide="award" class="w-10 h-10 text-yellow-400 mb-1 mx-auto"></i><p>完 璧</p></button>
                    <button class="assessment-btn p-2 w-24 flex flex-col items-center" data-level="2"><i data-lucide="thumbs-up" class="w-10 h-10 text-green-400 mb-1 mx-auto"></i><p>まあまあ</p></button>
                    <button class="assessment-btn p-2 w-24 flex flex-col items-center" data-level="1"><i data-lucide="book-open-check" class="w-10 h-10 text-blue-400 mb-1 mx-auto"></i><p>要復習</p></button>
                </div>
            </div>    </div><div id="theme-purchase-modal" class="fixed inset-0 bg-black/70 z-[60] items-center justify-center hidden p-4">
    <div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
        <h2 id="theme-purchase-title" class="text-xl font-bold mb-2"></h2>
        <div id="theme-preview" class="w-20 h-20 rounded-full mx-auto my-4 border-4 border-gray-200 dark:border-gray-600 shadow-inner"></div>
        <p id="theme-purchase-cost" class="mb-6"></p>
        <div class="flex justify-center space-x-4">
            <button id="theme-purchase-cancel" class="bg-gray-200 dark:bg-gray-600 px-6 py-2 rounded-lg">やめる</button>
            <button id="theme-purchase-confirm" class="primary-bg primary-bg-hover text-white px-6 py-2 rounded-lg transition-colors disabled:bg-gray-400 dark:disabled:bg-gray-500 disabled:cursor-not-allowed">交換する</button>
        </div>
    </div>
</div>

<div id="background-purchase-modal" class="fixed inset-0 bg-black/70 z-[60] items-center justify-center hidden p-4">
    <div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
        <h2 id="background-purchase-title" class="text-xl font-bold mb-2"></h2>
        <div id="background-preview" class="w-1/2 aspect-[9/16] rounded-lg mx-auto my-4 bg-gray-200 dark:bg-gray-800 bg-cover bg-center shadow-inner"></div>
        <p id="background-purchase-cost" class="mb-6"></p>
        <div class="flex justify-center space-x-4">
            <button id="background-purchase-cancel" class="bg-gray-200 dark:bg-gray-600 px-6 py-2 rounded-lg">やめる</button>
            <button id="background-purchase-confirm" class="primary-bg primary-bg-hover text-white px-6 py-2 rounded-lg transition-colors disabled:bg-gray-400 dark:disabled:bg-gray-500 disabled:cursor-not-allowed">交換する</button>
        </div>
    </div>
</div>

<div id="game-purchase-modal" class="fixed inset-0 bg-black/70 z-[60] items-center justify-center hidden p-4">
    <div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
        <h2 id="game-purchase-title" class="text-xl font-bold mb-4"></h2>
        
        <div id="game-preview-container" class="preview-carousel bg-gray-100 dark:bg-gray-800 rounded-lg">
            </div>
        <p id="game-purchase-cost" class="mb-6 font-bold text-lg primary-text"></p>
        <div class="flex justify-center space-x-4">
            <button id="game-purchase-cancel" class="bg-gray-200 dark:bg-gray-600 px-6 py-2 rounded-lg">やめる</button>
            <button id="game-purchase-confirm" class="primary-bg primary-bg-hover text-white px-6 py-2 rounded-lg transition-colors shadow-lg">交換する</button>
        </div>
    </div>
</div>

<div id="music-purchase-modal" class="fixed inset-0 bg-black/70 z-[60] items-center justify-center hidden p-4">
    <div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 text-center">
        <h2 id="music-purchase-title" class="text-xl font-bold mb-2"></h2>
        
        <div class="mx-auto my-6 text-primary relative inline-block">
             <div class="w-24 h-24 bg-gray-100 dark:bg-gray-600 rounded-full flex items-center justify-center mx-auto">
                 <i data-lucide="music" class="w-10 h-10 text-gray-400"></i>
             </div>
             <button id="music-preview-btn" class="absolute -bottom-2 -right-2 bg-pink-500 hover:bg-pink-600 text-white p-3 rounded-full shadow-lg transition-transform hover:scale-110">
                <i data-lucide="play" class="w-6 h-6 fill-current"></i>
             </button>
        </div>

        <p id="music-purchase-cost" class="mb-6 font-bold text-lg primary-text"></p>

        <div class="flex justify-center space-x-4">
            <button id="music-purchase-cancel" class="bg-gray-200 dark:bg-gray-600 px-6 py-2 rounded-lg">やめる</button>
            <button id="music-purchase-confirm" class="primary-bg primary-bg-hover text-white px-6 py-2 rounded-lg transition-colors shadow-lg">交換する</button>
        </div>
    </div>
</div>
    
    <div id="countdown-modal" class="fixed inset-0 bg-black/70 z-50 items-center justify-center hidden p-4"><div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6"><h2 id="countdown-modal-title" class="text-xl font-bold mb-4">カウントダウン設定</h2><div class="space-y-4"><input id="countdown-name" type="text" placeholder="イベント名 (例: 期末テスト)" class="w-full p-2 border rounded dark:bg-gray-800 dark:border-gray-600 appearance-none min-w-0"><input id="countdown-date" type="date" class="w-full block p-2 border rounded dark:bg-gray-800 dark:border-gray-600 appearance-none min-w-0"></div><div class="flex justify-between items-center mt-6"><button id="countdown-delete-btn" class="text-red-500 hover:text-red-700 font-semibold p-2 hidden"><i data-lucide="trash-2" class="w-5 h-5 inline-block mr-1"></i>削除</button><div class="flex space-x-2"><button id="countdown-cancel-btn" class="bg-gray-200 dark:bg-gray-600 px-6 py-2 rounded-lg">キャンセル</button><button id="countdown-save-btn" class="primary-bg primary-bg-hover text-white px-6 py-2 rounded-lg">保存</button></div></div></div></div>
   
    <div id="point-details-modal" class="fixed inset-0 bg-black/70 z-50 items-center justify-center hidden p-4"><div class="bg-white dark:bg-gray-700 rounded-lg shadow-xl w-full max-w-sm p-6 flex flex-col max-h-[90vh]"><div class="flex justify-between items-center mb-4 flex-shrink-0"><h2 class="text-xl font-bold">マイステータス</h2><button id="close-point-modal-btn" class="p-1"><i data-lucide="x"></i></button></div><div class="space-y-6 overflow-y-auto"><div class="text-center"><p class="text-sm text-gray-500">現在の学習ポイント</p><p class="text-4xl font-bold primary-text" id="modal-lp-display"></p></div><div><h3 class="font-semibold mb-2">テーマカラー</h3><div id="modal-theme-selector" class="grid grid-cols-4 gap-4"></div></div><div><h3 class="font-semibold mb-2">壁紙</h3><div id="modal-background-selector" class="grid grid-cols-3 gap-2"></div></div></div></div></div>
    <div id="toast" class="fixed top-5 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg opacity-0 transition-all duration-300 z-50 transform -translate-y-10"></div>
        
    <div id="quest-active-screen" class="focus-view-bg hidden fixed inset-0 bg-gray-900 text-gray-100 z-50 flex flex-col items-center justify-center p-4 transition-all duration-500 bg-cover bg-center">

        <div class="absolute inset-0 bg-black/60 z-0"></div>
        <div class="relative z-10 w-full h-full flex flex-col items-center justify-center">
        
        <div class="absolute top-6 right-6 flex items-center space-x-2 z-50">
            <button id="break-settings-btn" class="text-gray-400 p-2 rounded-full hover:bg-gray-700 transition-colors hidden">
                <i data-lucide="settings" class="w-7 h-7"></i>
            </button>
            <button id="end-quest-btn" class="text-gray-300 p-2 rounded-full hover:bg-gray-700 transition-colors">
                <i data-lucide="x" class="w-7 h-7"></i> </button>
        </div>
                
        <div id="quest-content-area" class="relative w-full h-full overflow-hidden">
            
            <div id="quest-section-view" class="hidden absolute inset-0 w-full h-full flex-col items-center justify-center p-4 z-10">
                <div class="text-center">
                    <h2 id="quest-section-title" class="text-2xl md:text-3xl font-bold mb-2 text-gray-400"></h2>
                    <p class="text-7xl md:text-9xl font-mono font-extrabold" id="quest-timer">25:00</p>
                    <p id="quest-progress" class="mt-4 text-lg text-gray-400"></p>
                </div>
            </div>

            <div id="quest-break-view" class="hidden absolute inset-0 w-full h-full flex-col items-center justify-center p-4 z-10">
                <div class="text-center mb-8 flex-shrink-0">
                    <h2 class="text-2xl md:text-3xl font-bold text-gray-400">☕ ブレイクタイム</h2>
                    <p class="text-5xl md:text-7xl font-mono font-extrabold" id="break-timer">05:00</p>
                </div>

                <div class="w-full max-w-sm overflow-y-auto max-h-[50vh]">
                    <div id="break-icon-grid" class="break-icon-grid-container">
                        </div>
                </div>
            </div>

            <div id="quest-transition-view" class="hidden absolute inset-0 w-full h-full flex-col items-center justify-center p-6 text-center z-20 animate-fadeIn bg-gray-900/95">
                <div class="mb-8">
                    <i id="transition-icon" data-lucide="arrow-right-circle" class="w-24 h-24 text-white opacity-80 mx-auto mb-4"></i>
                    <h2 id="transition-title" class="text-3xl md:text-4xl font-bold text-white mb-2"></h2>
                    <p id="transition-message" class="text-xl text-gray-300"></p>
                </div>
                
                <div class="bg-white/10 backdrop-blur-md rounded-xl p-6 w-full max-w-sm border border-white/20 mb-8">
                    <p class="text-sm text-gray-400 mb-1">NEXT</p>
                    <p id="transition-next-text" class="text-xl font-bold text-white truncate"></p>
                    <p id="transition-next-duration" class="text-sm text-gray-400 font-mono mt-1"></p>
                </div>

                <button id="transition-start-btn" class="primary-bg primary-bg-hover text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:scale-105 transition-transform flex items-center">
                    <i data-lucide="play" class="w-6 h-6 mr-2"></i>
                    始める
                </button>
            </div>

        </div>
        
            </div>
        </div>
    
    <div id="iframe-overlay" class="hidden fixed inset-0 bg-gray-900 z-[80] flex flex-col">
        <div class="bg-gray-800 p-2 flex justify-between items-center z-10 shadow-md">
            <span class="text-white font-bold ml-2">Game</span>
            <button id="close-iframe-btn" class="text-gray-300 p-2 rounded-full hover:bg-gray-700">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
        </div>
        
        <div class="relative flex-grow w-full h-full bg-white">
            <div id="iframe-loader" class="flex flex-col items-center justify-center">
                <div id="loader"></div> <p class="mt-4 text-gray-500 font-bold">Loading...</p>
            </div>
            <iframe id="break-iframe" class="w-full h-full absolute inset-0 opacity-0 transition-opacity duration-300" src="about:blank"></iframe>
        </div>
    </div>
    
    <div id="confirmation-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[70] flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-700 rounded-xl shadow-2xl p-6 w-full max-w-sm text-center">
            <h3 id="modal-title" class="text-lg font-bold text-gray-900 dark:text-white mb-4">クエストを終了しますか？</h3>
            <div class="flex justify-center space-x-4">
                <button id="modal-cancel-btn" class="px-6 py-2 rounded-lg bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold hover:bg-gray-300 dark:hover:bg-gray-500 transition">キャンセル</button>
                <button id="modal-confirm-btn" class="px-6 py-2 rounded-lg bg-red-500 text-white font-semibold hover:bg-red-600 transition">終了</button>
            </div>
        </div>
    </div>

    <div id="resume-quest-modal" class="hidden fixed inset-0 bg-black/80 z-[100] flex items-center justify-center p-4">
        <div class="bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-sm text-center">
            <div class="mb-4">
                <i data-lucide="alert-circle" class="w-12 h-12 text-yellow-500 mx-auto mb-2"></i>
                <h3 class="text-lg font-bold text-gray-900 dark:text-white">クエストを再開しますか？</h3>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">前回、クエストの途中でアプリが終了しました。</p>
            </div>
            <div class="flex flex-col space-y-3">
                <button id="resume-quest-yes-btn" class="w-full py-3 rounded-lg primary-bg primary-bg-hover text-white font-bold shadow-lg">
                    再開する
                </button>
                <button id="resume-quest-no-btn" class="w-full py-3 rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 font-bold">
                    終了してホームへ
                </button>
            </div>
        </div>
    </div>
    
    <div id="break-settings-modal" class="hidden fixed inset-0 bg-black/70 z-[70] flex items-center justify-center p-4">
        <div class="bg-gray-800 rounded-xl shadow-2xl p-6 w-full max-w-sm flex flex-col items-center max-h-[80vh]">
            <h3 class="text-lg font-bold text-white mb-4 text-center flex-shrink-0">コンテンツの編集</h3>
            
            <div class="w-full flex-grow overflow-y-auto mb-4">
                <h4 class="text-xs font-bold text-gray-400 mb-2 px-1">表示中 (ドラッグで並び替え)</h4>
                <div id="break-active-list" class="w-full space-y-2"></div>
    
                <h4 class="text-xs font-bold text-gray-400 mt-6 mb-2 px-1">追加可能</h4>
                <div id="break-inactive-list" class="w-full flex flex-wrap gap-2"></div>
            </div>
    
            <button id="break-settings-close-btn" class="mt-2 px-6 py-2 rounded-lg primary-bg primary-bg-hover text-white font-semibold transition flex-shrink-0">
                閉じる
            </button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const initialData = {
                quizzes: [
                    { id: 'math1', title: "数学 - 正負の数", subject: "数学", genre: "中1", tags: ['english1'], url: "https://docs.google.com/forms/d/e/1FAIpQLScsC0BFa_3gY-f-u4pW8Q22o_l3c0T-t_9c3z-q8pY6X-u8qQ/viewform?usp=sf_link" },
                    { id: 'english1', title: "英語 - be動詞", subject: "英語", genre: "中1", tags: ['math1', 'history1'], url: "https://docs.google.com/forms/d/e/1FAIpQLSfvtBwi1Tb1z6YEQOclBi4J7pxOc8lEILZ-OPZ4k6aebFJmTg/viewform" },
                    { id: 'science1', title: "理科 - 植物のつくり", subject: "理科", genre: "中1", tags: [], url: "https://docs.google.com/forms/d/e/1FAIpQLSfp-24sW_4xT8d_aK_b_nL5e-pX7a-j8vN-qA9rR_cT_uL-vQ/viewform?usp=sf_link" },
                    { id: 'japanese1', title: "国語 - 枕草子", subject: "国語", genre: "古典", tags: ['history1'], url: "https://docs.google.com/forms/d/e/1FAIpQLSe-0P7p_L-rT9c-yS_eD-wA9iR_bO8kM-nL-u_V-iE7xS-tQ/viewform?usp=sf_link" },
                    { id: 'history1', title: "社会 - 鎌倉時代", subject: "社会", genre: "歴史", tags: ['japanese1'], url: "https://docs.google.com/forms/d/e/1FAIpQLSeLprqPbZCZv2ufQ2qYqltnRiUE1FsBYODa_eNwOVO1NqZwBw/viewform?usp=pp_url" },
                ],
                
                themes: {
                    default: { name: 'デフォルト', color: '#4f46e5', hover: '#4338ca', cost: 0 },
                    green: { name: 'フォレスト', color: '#16a34a', hover: '#15803d', cost: 100 },
                    red: { name: 'サンセット', color: '#dc2626', hover: '#b91c1c', cost: 150 },
                    orange: { name: 'ビタミン', color: '#f97316', hover: '#ea580c', cost: 200 },
                    purple: { name: 'ミッドナイト', color: '#7c3aed', hover: '#6d28d9', cost: 250 },
                    pink: { name: 'チェリー', color: '#db2777', hover: '#be185d', cost: 300 },
                    teal: { name: 'オーシャン', color: '#0d9488', hover: '#0f766e', cost: 350 },
                },
                backgrounds: {
                    default: { name: 'デフォルト', url: '', cost: 0 , tone: 'system' },
                    sky: { name: '青空と流れ星', url: 'okumono_hosisoratate8.png', cost: 500, tone: 'light' },
                    night: { name: '手書きゆるドット', url: 'https://sozaino.site/wp-content/uploads/2022/01/yurudot32.png', cost: 700, tone: 'light' },
                    sdotb: { name: 'シャワードット(ブルー)', url: 'https://sozaino.site/wp-content/uploads/2020/11/sai-4.png', cost: 700, tone: 'light' },
                    utyuu: { name: '壮大な宇宙', url: 'https://sozaino.site/wp-content/uploads/2021/02/utyuu.jpg', cost: 700, tone: 'dark' },
                    jyanguru: { name: 'ジャングル', url: 'https://sozaino.site/wp-content/uploads/2025/07/okumono_jungle1.png', cost: 700, tone: 'dark' },
                    wapop: { name: '和ポップ（ピンク）', url: 'okumono_wapop3.png', cost: 700, tone: 'dark' },
                },
                
                games: {
                    // ID: { name: 'ゲーム名', url: 'URL', cost: 必要LP, icon: 'アイコン名' }
                    // previews: ['画像のURL', '動画のURL', ...] の形式で追加します
                    just100: { 
                        name: 'Just 1.00s', 
                        url: 'https://330march39.github.io/games/just1m_37928/', 
                        cost: 100, 
                        icon: 'gamepad-2',
                        // ▼▼▼ ここに追加 ▼▼▼
                        previews: [
                            'just100s.png', // 画像1
                            'just100s_2.png',
                            'just100s_3.png',
                            // 動画がある場合はここにmp4のURLを入れる
                            // 'https://www.w3schools.com/html/mov_bbb.mp4' 
                        ]
                    },
                    ColorHunter: { 
                        name: 'Color Hunter', 
                        url: 'https://330march39.github.io/games/color_hunter_24197/', 
                        cost: 300, 
                        icon: 'gamepad-2',
                        previews: [
                            'https://placehold.co/600x400/f97316/fff?text=Color+Hunter+1',
                            'https://placehold.co/600x400/0d9488/fff?text=Color+Hunter+2'
                        ]
                    },
                    MAKE10: { 
                        name: 'MAKE 10', 
                        url: 'https://330march39.github.io/games/make10_26518/', 
                        cost: 300, 
                        icon: 'gamepad-2',
                        previews: [
                            'https://placehold.co/600x400/f97316/fff?text=Color+Hunter+1',
                            'https://placehold.co/600x400/0d9488/fff?text=Color+Hunter+2'
                        ]
                    },
                },

                // ▼▼▼ 【追加】ここに音楽を追加していきます ▼▼▼
                // 音源ファイルはご自身でサーバー等にアップロードし、そのURLを貼ってください
                // 動作確認用にフリー素材のURLを入れています
                music: {
                    // ID: { name: '曲名', url: '音声ファイルのURL', cost: 必要LP }
                    chill1: { name: 'Chill Beats', url: 'https://cdn.pixabay.com/download/audio/2022/05/27/audio_1808fbf07a.mp3', cost: 150 },
                    piano1: { name: 'Relaxing Piano', url: 'https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3', cost: 200 },
                    
                    // 例: 自分の曲を追加する場合
                    // mySong1: { name: 'My Study BGM', url: './music/mysong.mp3', cost: 300 },
                }
            };

            let state;
            let chartInstances = {};
            let breakSortable = null;
            let focusTimer = { interval: null, defaultTime: 0, timeLeft: 0, isRunning: false, isPaused: false };
            let stopwatch = { interval: null, startTime: 0, elapsedTime: 0, isRunning: false, isPaused: false };
            let miniTimerTemporarilyHidden = false;
            let quizTimer = { startTime: null };

            let previewAudio = new Audio(); // 試聴用
            let previewTimeout = null;      // 30秒停止用タイマー
            
            const bgmAudio = new Audio();
            bgmAudio.loop = false; // プレイリスト再生のためループは手動制御
            let currentTrackIndex = 0;

            const $ = (s) => document.querySelector(s);
            const $$ = (s) => document.querySelectorAll(s);
            
            let homeTaskListEl, newTaskInput, newTaskNumberEl;

            let quest = {
                plan: [], // { id, type: 'section' | 'break', text?, duration }
                active: false,
                currentIndex: -1,
                timerInterval: null,
                timeLeft: 0,
                breakWindow: null
            };

            // --- スワイプ制御クラス（修正版: デッドゾーン＆ボタン修正） ---
            class SwipeHandler {
                constructor(element, options = {}) {
                    this.container = element;
                    this.content = element.querySelector('.swipe-content');
                    this.actionsContainer = element.querySelector('.swipe-actions');
                    
                    this.onComplete = options.onComplete || null;
                    this.onDelete = options.onDelete || null;
                    
                    this.actionsWidth = this.actionsContainer ? this.actionsContainer.offsetWidth : 0;
                    
                    this.startX = 0;
                    this.startY = 0;
                    this.currentX = 0;
                    this.startOffset = 0;
                    
                    this.isDragging = false; // 指が画面に触れているか
                    this.isSwiping = false;  // 実際にスワイプ動作（横移動）が確定したか
                    
                    this.initEvents();
                }
            
                initEvents() {
                    const start = (x, y, target) => {
                        // 入力フォームは除外
                        if (target.tagName === 'INPUT') return;
                        
                        // 既に開いている状態で、コンテンツ部分をタップしたら閉じる動作を優先
                        if (this.container.classList.contains('swiped-open') && target.closest('.swipe-content')) {
                             this.snapToClose();
                             return;
                        }

                        this.isDragging = true;
                        this.isSwiping = false; // リセット
                        this.startX = x;
                        this.startY = y;
                        
                        const style = window.getComputedStyle(this.content);
                        const matrix = new WebKitCSSMatrix(style.transform);
                        this.startOffset = matrix.m41; 
                        
                        // アニメーション一時停止
                        this.container.classList.add('is-dragging');
                    };
            
                    const move = (e, x, y) => {
                        if (!this.isDragging) return;
            
                        const diffX = x - this.startX;
                        const diffY = y - this.startY;
            
                        // --- ★修正ポイント: 不感帯（デッドゾーン）の設定 ---
                        // まだスワイプが確定していない場合
                        if (!this.isSwiping) {
                            // 縦移動の方が大きい場合はスワイプキャンセル（スクロール優先）
                            if (Math.abs(diffY) > Math.abs(diffX)) {
                                this.isDragging = false;
                                this.container.classList.remove('is-dragging');
                                return;
                            }
                            
                            // ★ここが重要: 横移動が15pxを超えるまでは画面を動かさない
                            // これにより、並び替えの長押し中の微細な揺れで削除ボタンが出るのを防ぐ
                            if (Math.abs(diffX) < 15) {
                                return; 
                            }
                            
                            // 15px以上動いたらスワイプ確定
                            this.isSwiping = true;
                            this.container.classList.add('is-swiping');
                        }

                        // ここから下はスワイプ確定後の処理
                        e.preventDefault(); // 画面スクロールを止める
            
                        let newX = this.startOffset + diffX;
            
                        // 右端制限
                        if (newX > 0) newX = 0;
                        // 左端制限
                        if (newX < -this.actionsWidth - 150) newX = -this.actionsWidth - 150;
            
                        this.currentX = newX;
                        this.content.style.transform = `translateX(${newX}px)`;
                    };
            
                    const end = () => {
                        if (!this.isDragging) return;
                        this.isDragging = false;
                        this.isSwiping = false;
                        this.container.classList.remove('is-dragging');
                        this.container.classList.remove('is-swiping');
            
                        // 閾値判定
                        if (this.currentX < -200) { // フルスワイプ削除
                            if (this.onDelete) {
                                this.content.style.transform = `translateX(-120vw)`;
                                this.performDelete();
                            } else {
                                this.snapToOpen();
                            }
                        } else if (this.currentX < -(this.actionsWidth / 2)) {
                            this.snapToOpen();
                        } else {
                            this.snapToClose();
                        }
                    };
            
                    // Touch Events
                    this.content.addEventListener('touchstart', (e) => start(e.touches[0].clientX, e.touches[0].clientY, e.target), { passive: true });
                    this.content.addEventListener('touchmove', (e) => move(e, e.touches[0].clientX, e.touches[0].clientY), { passive: false });
                    this.content.addEventListener('touchend', end);
            
                    // Mouse Events
                    this.content.addEventListener('mousedown', (e) => start(e.clientX, e.clientY, e.target));
                    window.addEventListener('mousemove', (e) => { if(this.isDragging) move(e, e.clientX, e.clientY); });
                    window.addEventListener('mouseup', () => { if(this.isDragging) end(); });
                    
                    // --- ★修正ポイント: ボタンイベントの確実な発火 ---
                    const completeBtn = this.actionsContainer ? this.actionsContainer.querySelector('.btn-complete') : null;
                    if (completeBtn) {
                        // touchstartでも反応するようにし、バブリングを止める
                        completeBtn.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
                        completeBtn.addEventListener('click', (e) => {
                            e.stopPropagation(); // 親要素への伝播を止める
                            this.snapToClose();
                            if (this.onComplete) setTimeout(() => this.onComplete(), 300);
                        });
                    }
            
                    const deleteBtn = this.actionsContainer ? this.actionsContainer.querySelector('.btn-delete') : null;
                    if (deleteBtn) {
                        deleteBtn.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: true });
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation(); // 親要素への伝播を止める
                            this.performDelete();
                        });
                    }
                }
            
                snapToOpen() {
                    this.content.style.transform = `translateX(-${this.actionsWidth}px)`;
                    this.container.classList.add('swiped-open');
                }
            
                snapToClose() {
                    this.content.style.transform = `translateX(0px)`;
                    this.container.classList.remove('swiped-open');
                }
            
                performDelete() {
                    this.container.style.height = this.container.offsetHeight + 'px';
                    this.container.classList.add('swipe-deleting');
                    
                    requestAnimationFrame(() => {
                        this.container.style.height = '0px';
                        setTimeout(() => {
                            if (this.onDelete) this.onDelete();
                        }, 300);
                    });
                }
            }

            // クエスト用 DOM要素
            const questView = $('#quest-view');
            const questPlanListEl = $('#quest-plan-list');
            const breakSettingsListEl = $('#break-settings-list');
            const startQuestBtn = $('#start-quest-btn');
            const addBreaksBtn = $('#add-breaks-btn');
            const addSectionBtn = $('#add-section-btn');
            const addBreakBtn = $('#add-break-btn');
            
            const questActiveScreen = $('#quest-active-screen');
            const questSectionView = $('#quest-section-view');
            const questBreakView = $('#quest-break-view');
            const questSectionTitle = $('#quest-section-title');
            const questTimerEl = $('#quest-timer');
            const breakTimerEl = $('#break-timer');
            const questProgressEl = $('#quest-progress');
            const endQuestBtn = $('#end-quest-btn');

            const confirmationModal = $('#confirmation-modal');
            const modalConfirmBtn = $('#modal-confirm-btn');
            const modalCancelBtn = $('#modal-cancel-btn');

            const iframeOverlay = $('#iframe-overlay');
            const breakIframe = $('#break-iframe');
            const closeIframeBtn = $('#close-iframe-btn');
            const breakIconGrid = $('#break-icon-grid');
            
            const loadState = () => {
                const defaultState = {
                    user: {
                        isRegistered: false, // 初回登録完了フラグ
                        name: 'ゲスト',
                        icon: '🙂',
                        grade: '',
                        id: Math.random().toString(36).substring(2, 9) // 簡易ID
                    },
                    profile: { 
                        lp: 0, 
                        unlockedThemes: ['default'], 
                        activeTheme: 'default',
                        unlockedBackgrounds: ['default'],
                        activeBackground: 'default',
                        unlockedGames: [], // 解放済みゲームID
                        unlockedMusic: [], // 解放済み音楽ID
                        tasksLastUpdated: null
                    },
                    tasks: [],
                    progress: {},
                    pinnedQuizzes: [],
                    countdowns: [],
                    focus: { 
                        totalTime: 0, 
                        mode: 'timer',
                        isRunning: false, // 実行中かどうかのフラグ
                        startTime: null,  // 開始時刻のタイムスタンプ
                        duration: 0       // タイマーの総時間
                    },
                    studyLog: {}, 
                    sessionLog: [],
                    savedQuest: null, // ★追加: クエストの中断データを保存する場所
                    settings: { backgroundScopeGlobal: true , 
                                manualDarkMode: false,
                                bgmEnabled: false,      // BGM機能のON/OFF
                                playlist: [],           // 再生リスト(IDの配列)
                                bgmVolume: 0.5          // 音量 (任意)
                              },
                    lastLogin: null,
                    breakIcons: [
                        { id: 'x', name: 'X (Twitter)', icon: 'message-circle', url: 'https://x.com', openMode: 'external', visible: true },
                        { id: 'instagram', name: 'Instagram', icon: 'instagram', url: 'https://www.instagram.com/', openMode: 'external', visible: true },
                        { id: 'youtube', name: 'YouTube', icon: 'youtube', url: 'https://www.youtube.com/', openMode: 'external', visible: true },
                        //{ id: 'scratch1', name: 'ﾎﾞﾗﾝﾃｨｱ', icon: 'gamepad-2', url: 'https://scratch.mit.edu/projects/543610448/fullscreen/', openMode: 'external', visible: true },
                        //{ id: 'scratch2', name: 'ﾌﾞﾘｻﾞｰｽﾞ', icon: 'gamepad-2', url: 'https://scratch.mit.edu/projects/415836558/fullscreen/', openMode: 'external', visible: true }
                    ],
                    
                };
                
                // --- ▼▼▼ 修正箇所 ▼▼▼ ---
                
                // 1. 読み込み先の変数を `let` で宣言
                let loaded = {};
                try {
                    // 2. 保存されたデータを取得
                    const savedData = localStorage.getItem('quizAppUltimateV8');
                    // 3. データが null や空文字でない場合のみ、JSONとしてパース（解析）する
                    if (savedData) {
                        loaded = JSON.parse(savedData);
                    }
                } catch (e) {
                    // 4. パースに失敗（データが破損）した場合
                    console.error("ローカルストレージの読み込みに失敗しました。データをリセットします:", e);
                    // 5. 破損したデータを削除し、`loaded` は空のままにする
                    localStorage.removeItem('quizAppUltimateV8');
                }
                
                // 6. デフォルト値をベースに、読み込んだ値で上書き（ネストされたオブジェクトも安全にマージ）
                // (ここは元のコードと同じ)
                state = {
                    ...defaultState,
                    ...loaded,
                    user: { ...defaultState.user, ...(loaded.user || {}) }, // ★追加
                    profile: { ...defaultState.profile, ...(loaded.profile || {}) },
                    focus: { ...defaultState.focus, ...(loaded.focus || {}) },
                    settings: { ...defaultState.settings, ...(loaded.settings || {}) },
                    breakIcons: loaded.breakIcons || defaultState.breakIcons
                };
                // --- ▲▲▲ 修正ここまで ▲▲▲ ---

                // 3. ログインボーナス処理 (元のロジックをそのまま流用)
                if(state.lastLogin !== new Date().toDateString()){
                    addLP(10000, 'ログインボーナス', false);
                    state.lastLogin = new Date().toDateString();
                    saveState(); // stateが完全に構築された後に保存
                }

                // 4. 今日の予定リセット処理
                const today = new Date().toDateString();
                if (state.profile.tasksLastUpdated !== today) {
                    console.log('日付が変わったため、タスクをリセットします。');
                    state.tasks = []; // タスクを空にする
                    state.profile.tasksLastUpdated = today; // 更新日を今日に設定
                }
            };
            
            const saveState = () => localStorage.setItem('quizAppUltimateV8', JSON.stringify(state));
            
           // 既存の updateAppearance 関数を、この新しいコードで完全に置き換えてください。
            
            const updateAppearance = () => {
                const appContainer = $('#app-container');
                const activeBgId = state.profile.activeBackground;
                const activeBg = initialData.backgrounds[activeBgId] || initialData.backgrounds['default'];
                const isGlobal = state.settings.backgroundScopeGlobal;
                const hasImage = activeBg && activeBg.url;
                
                // --- 1. テーマ決定ロジック ---
                let effectiveTone = activeBg.tone;
                
                if (effectiveTone === 'system') {
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        effectiveTone = 'dark';
                    } else {
                        effectiveTone = 'light';
                    }
                }
                
                // --- 2. 決定したテーマをHTML要素に適用 (修正済みのロジック) ---
                if (effectiveTone === 'dark') {
                    document.documentElement.classList.add('dark');
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.classList.remove('dark');
                    document.documentElement.setAttribute('data-theme', 'light');
                }
                
                // --- 3. 背景画像の適用ロジック ---
                if (isGlobal && hasImage) {
                    appContainer.style.backgroundImage = `url(${activeBg.url})`;
                } else {
                    appContainer.style.backgroundImage = 'none';
                }
            };

            const updateLpDisplay = () => {
                $('#lp-display').textContent = `${state.profile.lp} LP`;
                if ($('#point-details-modal').style.display === 'flex') {
                    $('#modal-lp-display').textContent = state.profile.lp;
                }
            };

            // カレンダー表示用の現在年月
            let currentCalendarDate = new Date();
            let selectedReportDate = new Date(); // 選択中の日付

            const renderEngine = {
                pages: {
                    'home-page': () => {
                        const today = new Date();
                        $('#today-date').textContent = `${today.getFullYear()}年 ${today.getMonth() + 1}月 ${today.getDate()}日 (${'日月火水木金土'[today.getDay()]}曜日)`;

                        const countdownContainer = $('#countdown-list');
                        countdownContainer.innerHTML = state.countdowns.length ? state.countdowns.map(cd => {
                            const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
                            const targetStart = new Date(cd.date);
                            targetStart.setHours(0,0,0,0);
                            const diffTime = targetStart - todayStart;
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            const dayText = diffDays > 0 ? `あと <span class="text-2xl font-bold primary-text">${diffDays}</span> 日` : diffDays === 0 ? `<span class="text-xl font-bold text-red-500">今日です！</span>` : `<span class="text-gray-500">終了</span>`;
                            return `<div class="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 flex items-center justify-between"><div><h3 class="font-semibold text-gray-800 dark:text-gray-200">${cd.name}</h3><p class="text-sm text-gray-500 dark:text-gray-400">${cd.date.replace(/-/g, '/')}</p></div><div class="flex items-center"><div class="mr-4">${dayText}</div><button class="edit-countdown-btn p-2 text-gray-400 hover:text-gray-600" data-id="${cd.id}"><i data-lucide="edit" class="w-4 h-4"></i></button></div></div>`;
                        }).join('') : `<p class="text-sm text-gray-500 text-center">右上の「+」ボタンでテストなどの日程を追加できます。</p>`;
                        
                        renderHomeTasks();
                    },
                    'study-page': () => {
                        const pinnedContainer = $('#pinned-quizzes');
                        const pinnedSectionContainer = pinnedContainer.parentElement;
                    
                        if (state.pinnedQuizzes.length > 0) {
                            pinnedSectionContainer.style.display = 'block';
                            const pinnedQuizzes = state.pinnedQuizzes.map(id => initialData.quizzes.find(q => q.id === id)).filter(Boolean);
                            pinnedContainer.innerHTML = pinnedQuizzes.map(q => createQuizCard(q, true)).join('');
                        } else {
                            pinnedSectionContainer.style.display = 'none';
                        }
                    
                        const allContainer = $('#all-quizzes');
                        const subjects = ['all', ...new Set(initialData.quizzes.map(q => q.subject))];
                        const activeFilter = $('#filter-container .active')?.dataset.filter || 'all';
                        $('#filter-container').innerHTML = subjects.map(s => `<button class="filter-btn ${s === activeFilter ? 'active primary-bg text-white' : 'bg-gray-200 dark:bg-gray-600'} px-4 py-1.5 rounded-full text-sm font-medium whitespace-nowrap" data-filter="${s}">${s === 'all' ? 'すべて' : s}</button>`).join('');
                    
                        const quizzes = initialData.quizzes.filter(q => activeFilter === 'all' || q.subject === activeFilter);
                        allContainer.innerHTML = quizzes.map(q => createQuizCard(q, state.pinnedQuizzes.includes(q.id))).join('');
                    },
                    // 変更後
                  'focus-page': () => {
                      updateFocusModeUI();
                      updateBackgrounds();
                        const activeBg = initialData.backgrounds[state.profile.activeBackground] || initialData.backgrounds['default'];
                        const hasImage = activeBg && activeBg.url;
                        const isGlobal = state.settings.backgroundScopeGlobal;
                        
                        $$('.focus-view-bg').forEach(el => {
                            // 「全体適用」がオフで、かつ画像がある場合のみ、集中モードの要素に直接背景を設定
                            if (!isGlobal && hasImage) {
                                el.style.backgroundImage = `url(${activeBg.url})`;
                            } else {
                                // 「全体適用」がオンの場合は、#app-containerの背景が見えるように自身の背景を消す
                                el.style.backgroundImage = 'none';
                            }
                        });
                    },
                    'my-chart-page': () => {
                        // --- 1. 統計データの計算と表示 ---
                        if (!state.sessionLog) state.sessionLog = [];
                        
                        const todayStr = new Date().toISOString().split('T')[0];
                        const now = new Date();
                        // 今週の月曜日を計算
                        const dayOfWeek = now.getDay(); // 0(日) - 6(土)
                        const diffToMon = now.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); 
                        const monday = new Date(now.setDate(diffToMon));
                        monday.setHours(0,0,0,0);
                    
                        // 集計
                        let todaySec = 0;
                        let weekSec = 0;
                        let totalSec = 0;
                    
                        state.sessionLog.forEach(log => {
                            totalSec += log.duration;
                            if (log.date === todayStr) {
                                todaySec += log.duration;
                            }
                            const logDate = new Date(log.date);
                            if (logDate >= monday) {
                                weekSec += log.duration;
                            }
                        });
                    
                        // 「59分は0時間」 -> Math.floor(seconds / 3600)
                        $('#report-stat-today').innerHTML = `${Math.floor(todaySec / 3600)}<span class="text-xs text-gray-500 ml-1">時間</span>`;
                        $('#report-stat-week').innerHTML = `${Math.floor(weekSec / 3600)}<span class="text-xs text-gray-500 ml-1">時間</span>`;
                        $('#report-stat-total').innerHTML = `${Math.floor(totalSec / 3600)}<span class="text-xs text-gray-500 ml-1">時間</span>`;
                    
                        // --- 2. 週間レポート（既存のグラフ） ---
                        // (データソースは studyLog のままでOK、あるいは sessionLog から再集計してもOK)
                        const activeTheme = initialData.themes[state.profile.activeTheme] || initialData.themes['default'];
                        const rgb = hexToRgb(activeTheme.color);
                        const chartBarColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.5)`;
                        const chartBorderColor = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 1)`;
                    
                        const labels = [];
                        const data = [];
                        for (let i = 6; i >= 0; i--) {
                            const d = new Date();
                            d.setDate(d.getDate() - i);
                            const day = d.toISOString().split('T')[0];
                            labels.push(`${d.getMonth()+1}/${d.getDate()}`);
                            
                            // sessionLogから該当日の合計を計算
                            const dayTotal = state.sessionLog
                                .filter(l => l.date === day)
                                .reduce((acc, cur) => acc + cur.duration, 0);
                                
                            data.push(dayTotal / 60); // 分単位
                        }
                        renderChart('study-time-chart', 'bar', { 
                            labels, 
                            datasets: [{ 
                                label: '学習時間', // (単位は軸に出るのでラベルはシンプルに)
                                data, 
                                backgroundColor: chartBarColor, 
                                borderColor: chartBorderColor, 
                                borderWidth: 1 
                            }] 
                        }, { 
                            responsive: true,
                            maintainAspectRatio: false, // 枠に合わせてリサイズ
                            scales: { 
                                y: { 
                                    beginAtZero: true,
                                    ticks: {
                                        // ★ここがポイント：最小単位を1(分)にする。これで0.xのような表示を防ぐ
                                        stepSize: 1, 
                                        autoSkip: true,
                                        // ★メモリの表示フォーマット関数
                                        callback: function(value) {
                                            if (value === 0) return '0';
                                            // 60で割り切れる（1時間, 2時間...）場合は「時間」表示
                                            if (value >= 60 && value % 60 === 0) {
                                                return (value / 60) + '時間';
                                            }
                                            // それ以外は「分」表示
                                            return value + '分';
                                        }
                                    }
                                } 
                            },
                            plugins: {
                                tooltip: {
                                    callbacks: {
                                        // ツールチップ（タップした時）の表示も「◯時間◯分」形式にする
                                        label: function(context) {
                                            const val = context.raw; // 分
                                            const h = Math.floor(val / 60);
                                            const m = Math.round(val % 60); // 念のため四捨五入
                                            if (h > 0) return ` ${h}時間 ${m}分`;
                                            return ` ${m}分`;
                                        }
                                    }
                                }
                            }
                        });
                    
                        // --- 3. カレンダーと詳細リストの描画 ---
                        renderCalendar();
                        renderDailyDetails(selectedReportDate);
                        
                        // カレンダーボタンのイベント設定（重複登録防止のため毎回クリアするか、onclickを使う）
                        $('#cal-prev-btn').onclick = () => {
                            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
                            renderCalendar();
                        };
                        $('#cal-next-btn').onclick = () => {
                            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
                            renderCalendar();
                        };
                    },
                    'settings-page': () => {
                        const settingsPage = $('#settings-page');
                        settingsPage.innerHTML = ''; // 一旦クリア

                        // --- 1. プロフィールカード (一番上) ---
                        const profileCard = document.createElement('div');
                        profileCard.id = 'settings-profile-card';
                        profileCard.className = 'bg-white dark:bg-gray-700 p-4 rounded-lg shadow mb-4 flex items-center cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-600 transition';
                        profileCard.innerHTML = `
                            <div class="w-16 h-16 rounded-full bg-gray-100 dark:bg-gray-800 flex items-center justify-center text-3xl mr-4 border-2" style="border-color: var(--primary-color);">
                                ${state.user.icon}
                            </div>
                            <div class="flex-grow">
                                <h3 class="font-bold text-lg">${state.user.name}</h3>
                                <p class="text-sm text-gray-500 dark:text-gray-400">${state.user.grade || '学年未設定'}</p>
                            </div>
                            <i data-lucide="chevron-right" class="text-gray-400"></i>
                        `;
                        profileCard.addEventListener('click', () => { openProfileModal(); });
                        settingsPage.appendChild(profileCard);

                        // --- 2. 通知設定 ---
                        const notifCard = document.createElement('div');
                        notifCard.id = 'notification-settings-card';
                        notifCard.className = 'bg-white dark:bg-gray-700 p-4 rounded-lg shadow mb-4';
                        notifCard.innerHTML = `
                            <h3 class="font-semibold mb-2">通知設定</h3>
                            <button id="notification-permission-btn" class="w-full primary-bg primary-bg-hover text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center mb-4"><i data-lucide="bell-ring" class="w-5 h-5 mr-2"></i>ブラウザ通知を許可</button>
                        `;
                        // 通知許可済みなら隠す
                        if ('Notification' in window && Notification.permission === 'granted') {
                            notifCard.style.display = 'none';
                        }
                        settingsPage.appendChild(notifCard);
                        // イベントリスナーはグローバルで設定済みだが、動的生成なので再度紐付けるか、あるいはIDベースの既存リスナーが動くようにIDを維持

                        // --- 3. テーマカラー設定 ---
                        const themeCard = document.createElement('div');
                        themeCard.className = 'bg-white dark:bg-gray-700 p-4 rounded-lg shadow mb-4';
                        themeCard.innerHTML = `
                             <h3 class="font-semibold mb-2">テーマカラーを選択</h3>
                             <div id="theme-selector" class="grid grid-cols-4 gap-4">
                                ${state.profile.unlockedThemes.map(id => {
                                    const theme = initialData.themes[id];
                                    const isActive = state.profile.activeTheme === id;
                                    return `<div class="text-center">
                                        <button class="theme-btn w-12 h-12 rounded-full border-4 ${isActive ? 'border-blue-500' : 'border-transparent'} relative" style="background-color: ${theme.color}" data-theme="${id}"></button>
                                        <p class="text-xs mt-1">${theme.name}</p>
                                    </div>`;
                                }).join('')}
                             </div>
                        `;
                        settingsPage.appendChild(themeCard);

                        // --- 4. 壁紙設定 ---
                        const bgCard = document.createElement('div');
                        bgCard.className = 'bg-white dark:bg-gray-700 p-4 rounded-lg shadow mb-4';
                        bgCard.innerHTML = `
                            <h3 class="font-semibold mb-2">壁紙を選択</h3>
                            <div id="background-selector" class="grid grid-cols-3 gap-4">
                                ${state.profile.unlockedBackgrounds.map(id => {
                                    const bg = initialData.backgrounds[id];
                                    const isActive = state.profile.activeBackground === id;
                                    return `<div class="text-center">
                                        <button class="background-btn w-full h-20 rounded-lg border-4 ${isActive ? 'border-blue-500' : 'border-transparent'} relative bg-gray-500 bg-cover bg-center" style="background-image: ${bg.url ? `url(${bg.url})` : 'none'}" data-bg="${id}"></button>
                                        <p class="text-xs mt-1">${bg.name}</p>
                                    </div>`;
                                }).join('')}
                            </div>
                            <hr class="my-4 border-gray-200 dark:border-gray-600">
                            <div class="flex items-center justify-between">
                                <p class="font-semibold">壁紙をアプリ全体に適用</p>
                                <input type="checkbox" id="background-scope-toggle" class="toggle-checkbox" ${state.settings.backgroundScopeGlobal ? 'checked' : ''}>
                            </div>
                        `;
                        settingsPage.appendChild(bgCard);

                        // --- 5. BGM設定 (一番下に移動＆デザイン刷新) ---
                        const bgmCard = document.createElement('div');
                        bgmCard.className = 'bg-white dark:bg-gray-700 p-4 rounded-lg shadow mb-20'; // pb確保
                        
                        // BGMカードの中身を構築
                        bgmCard.innerHTML = `
                            <h3 class="font-semibold mb-2 flex items-center justify-between">
                                <div class="flex items-center">
                                    <i data-lucide="music" class="w-5 h-5 mr-2 primary-text"></i>
                                    <span>BGM設定 (クエスト中)</span>
                                </div>
                                <div class="flex items-center">
                                    <input type="checkbox" id="bgm-toggle" class="toggle-checkbox" ${state.settings.bgmEnabled ? 'checked' : ''}>
                                </div>
                            </h3>
                            <p class="text-xs text-gray-500 mb-4">ONにすると、クエストの「学習セクション」中に以下のリスト順で再生されます。</p>
                            
                            <h4 class="text-sm font-bold mb-2 flex items-center"><i data-lucide="list-music" class="w-4 h-4 mr-1"></i> プレイリスト</h4>
                            <div id="playlist-container" class="space-y-2 mb-6 min-h-[50px] bg-gray-50 dark:bg-gray-800/50 rounded-lg p-2">
                                </div>
                            
                            <h4 class="text-sm font-bold mb-2 flex items-center"><i data-lucide="library" class="w-4 h-4 mr-1"></i> 追加可能な曲</h4>
                            <div id="unlocked-music-list" class="flex flex-wrap gap-2">
                                </div>
                        `;
                        settingsPage.appendChild(bgmCard);

                        // --- BGMロジックの実装 ---

                        // 1. トグルスイッチ
                        const bgmToggle = bgmCard.querySelector('#bgm-toggle');
                        bgmToggle.addEventListener('change', (e) => {
                            state.settings.bgmEnabled = e.target.checked;
                            saveState();
                        });

                        // 2. プレイリスト描画関数
                        const renderPlaylist = () => {
                            const container = bgmCard.querySelector('#playlist-container');
                            if (state.settings.playlist.length === 0) {
                                container.innerHTML = '<p class="text-xs text-gray-400 text-center py-4">曲がありません。<br>下のリストから追加してください。</p>';
                            } else {
                                container.innerHTML = '';
                                state.settings.playlist.forEach((id, index) => {
                                    const track = initialData.music[id];
                                    if(!track) return; 

                                    const itemEl = document.createElement('div');
                                    itemEl.className = 'bg-white dark:bg-gray-600 rounded-lg p-2 flex items-center shadow-sm border border-gray-100 dark:border-gray-500';
                                    itemEl.setAttribute('data-id', id);
                                    
                                    itemEl.innerHTML = `
                                        <div class="playlist-handle text-gray-400 cursor-grab active:cursor-grabbing p-2 mr-1">
                                            <i data-lucide="grip-vertical" class="w-5 h-5"></i>
                                        </div>
                                        <div class="flex-grow min-w-0">
                                            <p class="font-bold text-sm truncate text-gray-800 dark:text-gray-100">${track.name}</p>
                                        </div>
                                        <div class="flex items-center space-x-1">
                                            <button class="preview-bgm-btn p-2 rounded-full text-indigo-500 hover:bg-indigo-50 dark:hover:bg-gray-500 transition" title="試し聞き">
                                                <i data-lucide="play-circle" class="w-5 h-5"></i>
                                            </button>
                                            <button class="remove-bgm-btn p-2 rounded-full text-red-500 hover:bg-red-50 dark:hover:bg-gray-500 transition" title="リストから削除">
                                                <i data-lucide="x-circle" class="w-5 h-5"></i>
                                            </button>
                                        </div>
                                    `;

                                    // 試聴ボタン
                                    const previewBtn = itemEl.querySelector('.preview-bgm-btn');
                                    previewBtn.addEventListener('click', () => {
                                        toggleMusicPreview(track.url, previewBtn);
                                    });

                                    // 削除ボタン
                                    const removeBtn = itemEl.querySelector('.remove-bgm-btn');
                                    removeBtn.addEventListener('click', () => {
                                        stopMusicPreview(); // 削除時は停止
                                        state.settings.playlist.splice(index, 1);
                                        saveState();
                                        renderPlaylist();
                                        renderUnlockedList();
                                    });

                                    container.appendChild(itemEl);
                                });

                                // Sortable.js 適用 (★ここを修正)
                                Sortable.create(container, {
                                    handle: '.playlist-handle',
                                    animation: 150,
                                    ghostClass: 'sortable-ghost',
                                    delay: 200, // ★長押し200msでドラッグ開始
                                    delayOnTouchOnly: true, // ★タッチ操作のみ遅延有効
                                    touchStartThreshold: 5, // ★5px以上の移動はスクロール判定
                                    onEnd: (evt) => {
                                        const item = state.settings.playlist.splice(evt.oldIndex, 1)[0];
                                        state.settings.playlist.splice(evt.newIndex, 0, item);
                                        saveState();
                                    }
                                });
                            }
                            lucide.createIcons();
                        };

                        // 3. 追加可能リスト描画関数 (重複排除ロジック入り)
                        const renderUnlockedList = () => {
                            const container = bgmCard.querySelector('#unlocked-music-list');
                            // プレイリストに含まれていない曲だけを抽出
                            const availableMusic = state.profile.unlockedMusic.filter(id => !state.settings.playlist.includes(id));

                            if (availableMusic.length === 0) {
                                container.innerHTML = '<span class="text-xs text-gray-400">追加できる曲がありません</span>';
                            } else {
                                container.innerHTML = availableMusic.map(id => {
                                    const track = initialData.music[id];
                                    return `<button class="add-to-playlist-btn bg-gray-50 dark:bg-gray-800 border dark:border-gray-600 px-3 py-2 rounded-full text-xs font-bold transition flex items-center hover:bg-gray-100 dark:hover:bg-gray-700" data-id="${id}" style="color: var(--primary-color); border-color: var(--primary-color);">
                                        <i data-lucide="plus" class="w-3 h-3 mr-1"></i>${track.name}
                                    </button>`;
                                }).join('');

                                // 追加ボタンイベント
                                container.querySelectorAll('.add-to-playlist-btn').forEach(btn => {
                                    btn.addEventListener('click', (e) => {
                                        const id = btn.dataset.id;
                                        state.settings.playlist.push(id);
                                        saveState();
                                        renderPlaylist();
                                        renderUnlockedList();
                                    });
                                });
                            }
                            lucide.createIcons();
                        };

                        // 初回描画実行
                        renderPlaylist();
                        renderUnlockedList();

                        // 壁紙スイッチのイベントリスナー再設定 (innerHTML書き換えで消えるため)
                        const bgScopeToggle = settingsPage.querySelector('#background-scope-toggle');
                        if(bgScopeToggle) {
                            bgScopeToggle.addEventListener('change', (e) => {
                                state.settings.backgroundScopeGlobal = e.target.checked;
                                saveState();
                                updateAppearance();
                            });
                        }
                        
                        // 通知許可ボタンのイベント再設定
                        const notifBtn = settingsPage.querySelector('#notification-permission-btn');
                        if(notifBtn){
                            notifBtn.addEventListener('click', async () => {
                                if (!('Notification' in window)) { showToast('お使いのブラウザは通知に対応していません。'); return; }
                                const permission = await Notification.requestPermission();
                                if (permission === 'granted') { 
                                    showToast('通知が許可されました！'); 
                                    new Notification('StudyQuestへようこそ！', { body: '通知設定がオンになりました。' }); 
                                    notifCard.style.display = 'none';
                                } else { 
                                    showToast('通知が拒否されました。'); 
                                }
                            });
                        }

                        lucide.createIcons();
                    },
                },
                renderAll: () => {
                    for(const pageId in renderEngine.pages){
                        if($(`#${pageId}`).classList.contains('active')){
                            renderEngine.pages[pageId]();
                        }
                    }
                    updateLpDisplay();
                    const activeTheme = initialData.themes[state.profile.activeTheme] || initialData.themes['default'];
                    document.documentElement.style.setProperty('--primary-color', activeTheme.color);
                    document.documentElement.style.setProperty('--primary-color-hover', activeTheme.hover);
                }
            };

            // カレンダー描画関数
            const renderCalendar = () => {
                const year = currentCalendarDate.getFullYear();
                const month = currentCalendarDate.getMonth();
                
                $('#cal-month-title').textContent = `${year}年 ${month + 1}月`;
                
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                const startDayOfWeek = firstDay.getDay(); // 0:Sun
                
                const grid = $('#calendar-grid');
                grid.innerHTML = '';
                
                // 空白セル
                for(let i=0; i<startDayOfWeek; i++) {
                    grid.innerHTML += `<div></div>`;
                }
                
                // 日付セル
                for(let d=1; d<=daysInMonth; d++) {
                    // ★修正: toISOStringを使わず、手動でローカル日付文字列(YYYY-MM-DD)を作る
                    const cellMonth = String(month + 1).padStart(2, '0');
                    const cellDay = String(d).padStart(2, '0');
                    const dateStr = `${year}-${cellMonth}-${cellDay}`;
                    
                    // ログがあるかチェック
                    const hasLog = state.sessionLog.some(l => l.date === dateStr);
                    
                    // ★修正: 選択中の日付比較もローカル時間で行う
                    const selY = selectedReportDate.getFullYear();
                    const selM = String(selectedReportDate.getMonth() + 1).padStart(2, '0');
                    const selD = String(selectedReportDate.getDate()).padStart(2, '0');
                    const selectedDateStr = `${selY}-${selM}-${selD}`;
                    const isSelected = selectedDateStr === dateStr;
    
                    // ★修正: 今日の日付比較もローカル時間で行う
                    const now = new Date();
                    const nowY = now.getFullYear();
                    const nowM = String(now.getMonth() + 1).padStart(2, '0');
                    const nowD = String(now.getDate()).padStart(2, '0');
                    const todayStr = `${nowY}-${nowM}-${nowD}`;
                    const isToday = todayStr === dateStr;
    
                    let cellClass = "h-8 w-8 mx-auto flex flex-col items-center justify-center rounded-full cursor-pointer transition text-sm relative ";
                    let styleStr = ""; // ★追加: 動的なスタイルを格納する変数
                    
                    if (isSelected) {
                        cellClass += "primary-bg text-white font-bold shadow-md";
                    } else if (isToday) {
                        cellClass += "border-2 font-bold";
                        styleStr = "border-color: var(--primary-color); color: var(--primary-color);";
                    } else {
                        cellClass += "hover:bg-gray-100 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300";
                    }
    
                    // マーカー（ログがある日）
                    const marker = hasLog && !isSelected ? `<span class="absolute bottom-1 w-1 h-1 rounded-full" style="background-color: var(--primary-color);"></span>` : '';
    
                    const cell = document.createElement('div');
                    cell.className = "text-center";
                    cell.innerHTML = `<div class="${cellClass}" style="${styleStr}">${d}${marker}</div>`;
                    
                    cell.addEventListener('click', () => {
                        selectedReportDate = new Date(year, month, d);
                        renderCalendar(); // 選択状態更新のため再描画
                        renderDailyDetails(selectedReportDate);
                    });
                    
                    grid.appendChild(cell);
                }
            };
    
            // 指定した日の詳細リストを表示する関数
            const renderDailyDetails = (targetDate) => {
                // ★修正: ここもtoISOStringを使わず、ローカル時間で検索キーを作る
                const y = targetDate.getFullYear();
                const m = String(targetDate.getMonth() + 1).padStart(2, '0');
                const d = String(targetDate.getDate()).padStart(2, '0');
                const dateStr = `${y}-${m}-${d}`;
    
                const displayDate = `${targetDate.getMonth()+1}月${targetDate.getDate()}日`;
                
                $('#detail-date-title').textContent = `${displayDate} の詳細`;
                
                const sessions = state.sessionLog.filter(l => l.date === dateStr);
                const listContainer = $('#study-session-list');
                
                if (sessions.length === 0) {
                    listContainer.innerHTML = `<div class="flex flex-col items-center justify-center py-8 text-gray-400"><i data-lucide="book-off" class="w-8 h-8 mb-2"></i><p class="text-xs">記録がありません</p></div>`;
                } else {
                    // 終了時刻の降順などで表示すると見やすい（ここでは記録順）
                    listContainer.innerHTML = sessions.map(s => {
                        // 秒を分に変換
                        const min = Math.floor(s.duration / 60);
                        const sec = s.duration % 60;
                        const durationText = min > 0 ? `${min}分` : `${sec}秒`;
                        
                        return `
                            <div class="flex items-center justify-between bg-white dark:bg-gray-700 p-3 rounded-lg shadow-sm border-l-4" style="border-left-color: var(--primary-color);">
                                <div class="flex-grow min-w-0 mr-4">
                                    <h4 class="font-bold text-sm text-gray-800 dark:text-gray-200 truncate">${s.title}</h4>
                                </div>
                                <div class="text-right flex-shrink-0">
                                    <p class="text-lg font-mono font-bold primary-text leading-none">${durationText}</p>
                                    <p class="text-xs text-gray-400 mt-1">${s.endTime || '--:--'}</p>
                                </div>
                            </div>
                        `;
                    }).reverse().join(''); // 新しい順に表示
                }
                lucide.createIcons();
            };
            
           const createQuizCard = (quiz, isPinned) => {
                if(!quiz) return '';
                const progress = state.progress[quiz.id];
                
                // アイコンの形定義
                const levelIcons = { 1: 'book-open-check', 2: 'thumbs-up', 3: 'award'};
                
                // ★色定義を追加 (モーダルに合わせた色系統)
                // 視認性を良くするため、モーダルの400番より少し濃い500番を使用しています
                const levelColors = { 1: 'text-blue-500', 2: 'text-green-500', 3: 'text-yellow-500'};

                // 進捗がある場合の色を取得
                const color = progress ? levelColors[progress.level] : '';

                return `<div class="bg-white dark:bg-gray-700 rounded-lg shadow-sm p-3 flex items-center justify-between quiz-card" data-id="${quiz.id}">
                            <div class="flex items-center min-w-0">
                                <div class="w-5 h-5 mr-3 flex-shrink-0">
                                    ${progress ? `<i data-lucide="${levelIcons[progress.level]}" class="${color}"></i>` : ``}
                                </div>
                                <div class="truncate">
                                    <h3 class="font-semibold text-gray-800 dark:text-gray-200 truncate">${quiz.title}</h3>
                                    <p class="text-sm text-gray-500 dark:text-gray-400">${quiz.subject} - ${quiz.genre}</p>
                                </div>
                            </div>
                            <button class="pin-btn p-2 -mr-2 flex-shrink-0" data-id="${quiz.id}">
                                <i data-lucide="pin" class="w-5 h-5 ${isPinned ? 'primary-text fill-current' : 'text-gray-400'}"></i>
                            </button>
                        </div>`;
            };
            
            const renderChart = (canvasId, type, data, options) => {
                const ctx = $(`#${canvasId}`).getContext('2d');
                if(chartInstances[canvasId]) chartInstances[canvasId].destroy();
                chartInstances[canvasId] = new Chart(ctx, { type, data, options });
            };

            const showToast = (message) => {
                const toast = $('#toast'); toast.textContent = message; toast.classList.remove('opacity-0', '-translate-y-10');
                setTimeout(() => toast.classList.add('opacity-0', '-translate-y-10'), 2000);
            };

            const addLP = (amount, reason, show = true) => {
                state.profile.lp += amount;
                if(show) showToast(`${reason}で ${amount} LP 獲得！`);
                updateLpDisplay();
            };
            
            const formatTime = (s) => {
                const totalSeconds = Math.floor(s);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                if (hours > 0) return `${hours}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
                return `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            };

            // ▼▼▼ 【追加】BGM制御関数群 ▼▼▼
            const playBGM = () => {
                if (!state.settings.bgmEnabled || state.settings.playlist.length === 0) return;
                
                // プレイリストが空でなければ再生
                if (bgmAudio.paused) {
                    const trackId = state.settings.playlist[currentTrackIndex];
                    const track = initialData.music[trackId];
                    if (track) {
                        // ソースが設定されていなければ設定
                        if (!bgmAudio.src || !bgmAudio.src.includes(track.url)) {
                            bgmAudio.src = track.url;
                        }
                        bgmAudio.play().catch(e => console.log('再生エラー(ユーザー操作が必要かも):', e));
                    }
                }
            };

            const pauseBGM = () => {
                bgmAudio.pause();
            };

            const stopBGM = () => {
                bgmAudio.pause();
                bgmAudio.currentTime = 0;
            };

            // 曲が終わったら次の曲へ
            bgmAudio.addEventListener('ended', () => {
                currentTrackIndex++;
                if (currentTrackIndex >= state.settings.playlist.length) {
                    currentTrackIndex = 0; // 最初に戻る
                }
                const nextTrackId = state.settings.playlist[currentTrackIndex];
                const nextTrack = initialData.music[nextTrackId];
                if (nextTrack) {
                    bgmAudio.src = nextTrack.url;
                    bgmAudio.play();
                }
            });

            // 【追加】タイマーに時間を加算する関数
            const addTimerTime = (seconds) => {
                if (focusTimer.isRunning) return; // 実行中は時間を変更できないようにする
                focusTimer.timeLeft += seconds;
                $('#focus-timer-display').textContent = formatTime(focusTimer.timeLeft);
            };
            
            // 【追加】タイマー表示をリセットする関数
            const resetTimerDisplay = () => {
                if (focusTimer.isRunning) return;
                focusTimer.timeLeft = 0;
                $('#focus-timer-display').textContent = formatTime(0);
            };
            
            const formatStopwatchTime = (s) => {
                const totalSeconds = s;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = Math.floor(totalSeconds % 60);
                // const ms = ... の行を削除
                return `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`; // 返り値からmsを削除
            };

            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            };

            const logStudyTime = (type, seconds) => {
                const today = new Date().toISOString().split('T')[0];
                if (!state.studyLog[today]) state.studyLog[today] = { focus: 0, quiz: 0 };
                state.studyLog[today][type] += seconds;
            };
            // 詳細なセッションログを記録する関数
            const recordSession = (title, durationSeconds) => {
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
                
                // 時間フォーマット (HH:MM)
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const endTimeStr = `${hours}:${minutes}`;
            
                const newSession = {
                    id: Date.now(),
                    date: dateStr,
                    title: title,
                    duration: durationSeconds,
                    endTime: endTimeStr
                };
            
                // stateに追加
                if (!state.sessionLog) state.sessionLog = [];
                state.sessionLog.push(newSession);
                
                // 既存の集計用ログも更新（互換性のため）
                logStudyTime('focus', durationSeconds); // または 'quiz' など適宜
                saveState();
            };

            const renderHomeTasks = () => {
                if (!homeTaskListEl) return;

                if (!state.tasks || state.tasks.length === 0) {
                    homeTaskListEl.innerHTML = `<p class="text-center text-sm text-gray-500">今日の予定はありません。</p>`;
                } else {
                    homeTaskListEl.innerHTML = ''; // 一旦クリア
                    
                    state.tasks.forEach((task, index) => {
                        const isCompleted = task.completed || false;
                        const textStyle = isCompleted ? 'line-through text-gray-400 dark:text-gray-500' : '';
                        
                        // ★スワイプ用構造
                        const taskEl = document.createElement('div');
                        // 並び替え時のID識別用に data-id を追加
                        taskEl.setAttribute('data-id', task.id); 
                        taskEl.className = `task-item swipe-container relative overflow-hidden rounded-lg mb-2`; 
                        
                        taskEl.innerHTML = `
                            <div class="swipe-actions">
                                <button class="btn-complete swipe-btn bg-gray-400 w-[70px]">
                                    <i data-lucide="check" class="w-6 h-6"></i>
                                    <span>完了</span>
                                </button>
                                <button class="btn-delete swipe-btn bg-red-500 w-[70px]">
                                    <i data-lucide="trash-2" class="w-6 h-6"></i>
                                    <span>削除</span>
                                </button>
                            </div>

                            <div class="swipe-content flex items-center p-2 bg-white dark:bg-gray-800 shadow-sm relative z-10 ${isCompleted ? 'bg-gray-100 dark:bg-gray-900' : ''}">
                                <span class="font-bold w-6 text-center text-gray-600 dark:text-gray-400 shrink-0">${index + 1}</span>
                                
                                <input type="text" value="${task.text}" class="task-text-input flex-grow min-w-0 bg-transparent p-1 focus:outline-none rounded ${textStyle}" ${isCompleted ? 'disabled' : ''}>
                                
                                <button type="button" class="task-handle cursor-grab active:cursor-grabbing text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-opacity p-2 shrink-0 ${isCompleted ? 'invisible' : ''}">
                                    <i data-lucide="grip-vertical" class="w-5 h-5"></i>
                                </button>
                            </div>
                        `;
                        
                        homeTaskListEl.appendChild(taskEl);
                        
                        // ★スワイプ機能の適用
                        new SwipeHandler(taskEl, {
                            onComplete: () => {
                                const taskToUpdate = state.tasks.find(t => t.id === task.id);
                                if (taskToUpdate) {
                                    taskToUpdate.completed = !taskToUpdate.completed; // トグル
                                    saveState();
                                    renderHomeTasks(); // 再描画
                                }
                            },
                            onDelete: () => {
                                state.tasks = state.tasks.filter(t => t.id !== task.id);
                                saveState();
                                setTimeout(renderHomeTasks, 100); 
                                showToast('タスクを削除しました');
                            }
                        });
                        
                        // テキスト変更イベント
                        taskEl.querySelector('.task-text-input').addEventListener('change', (e) => {
                            const taskToUpdate = state.tasks.find(t => t.id === task.id);
                            if (taskToUpdate) {
                                taskToUpdate.text = e.target.value;
                                saveState();
                            }
                        });
                    });
                }
                
                if(newTaskNumberEl) newTaskNumberEl.textContent = state.tasks.length + 1;

                // ★重要: 生成したリストの中に対してアイコン生成を実行
                lucide.createIcons({
                    root: homeTaskListEl,
                    nameAttr: 'data-lucide',
                    attrs: {
                        class: "w-5 h-5" // デフォルトサイズ指定
                    }
                });
            };

            document.body.addEventListener('click', e => {
                const quizCard = e.target.closest('.quiz-card');
                if (quizCard && !e.target.closest('.pin-btn')) {
                    const quiz = initialData.quizzes.find(q => q.id === quizCard.dataset.id);
                    $('#quiz-modal-title').textContent = quiz.title;
                    
                    // ★★★ ローダーを再表示する処理を追加 ★★★
                    $('#loader').parentElement.style.display = 'flex'; 
                
                    $('#quiz-iframe').classList.add('invisible');
                    $('#quiz-modal').dataset.currentQuiz = quiz.id;
                    $('#quiz-modal').style.display = 'flex';
                    quizTimer.startTime = Date.now();
                    setTimeout(() => {
                        $('#quiz-iframe').src = quiz.url;
                        $('#quiz-iframe').onload = () => {
                            $('#loader').parentElement.style.display = 'none'; 
                            $('#quiz-iframe').classList.remove('invisible');
                        };
                    }, 100);
                }
                const pinBtn = e.target.closest('.pin-btn');
                if(pinBtn) {
                    const quizId = pinBtn.dataset.id;
                    state.pinnedQuizzes.includes(quizId) ? state.pinnedQuizzes = state.pinnedQuizzes.filter(id => id !== quizId) : state.pinnedQuizzes.push(quizId);
                    saveState(); renderEngine.pages['study-page'](); lucide.createIcons();
                }
                
                const filterBtn = e.target.closest('.filter-btn');
                if(filterBtn) {
                     $$('#filter-container .filter-btn').forEach(b => {
                         b.classList.remove('active', 'primary-bg', 'text-white');
                         b.classList.add('bg-gray-200', 'dark:bg-gray-600');
                     });
                     filterBtn.classList.add('active', 'primary-bg', 'text-white');
                     filterBtn.classList.remove('bg-gray-200', 'dark:bg-gray-600');
                     renderEngine.pages['study-page']();
                     lucide.createIcons();
                }

                const closeModalBtn = e.target.closest('.close-modal-btn');
                if (closeModalBtn) {
                    const modal = $(`#${closeModalBtn.dataset.modal}`);
                    modal.style.display = 'none';
                    if (closeModalBtn.dataset.modal === 'quiz-modal') {
                        $('#assessment-modal').dataset.quizId = modal.dataset.currentQuiz;
                        $('#assessment-modal').style.display = 'flex';
                        if(quizTimer.startTime) {
                            const elapsed = Math.round((Date.now() - quizTimer.startTime) / 1000);
                            const title = $('#quiz-modal-title').textContent || 'クイズ';
                            recordSession(title, elapsed);
                            quizTimer.startTime = null;
                            saveState();
                        }
                    }
                }
                
                const assessmentBtn = e.target.closest('.assessment-btn');
                if(assessmentBtn) {
                    const level = parseInt(assessmentBtn.dataset.level);
                    const quizId = $('#assessment-modal').dataset.quizId;
                    
                    // 1. 進捗データを保存
                    state.progress[quizId] = { level, date: new Date().toISOString() };
                    addLP(level * 5, 'クイズ評価');
                    saveState();
                    
                    // 2. ★重要★ 現在のアクティブなページを強制的に再描画する
                    // renderEngine.renderAll() は 'active' クラスがついているページだけを描画するため、これでOKです
                    renderEngine.renderAll();
                    
                    // 3. アイコン（Lucide）を再生成する
                    // HTMLが書き換わった直後はアイコンが <i> タグのままなので、これを <svg> に変換します
                    lucide.createIcons();

                    // 4. モーダルを閉じる
                    $('#assessment-modal').style.display = 'none';
                }

                const themeBtn = e.target.closest('.theme-btn');
                if(themeBtn){
                    const themeId = themeBtn.dataset.theme;
                    if(state.profile.unlockedThemes.includes(themeId)) {
                        state.profile.activeTheme = themeId;
                        saveState();
                        renderEngine.renderAll();
                    } else {
                        const theme = initialData.themes[themeId];
                        const confirmBtn = $('#theme-purchase-confirm');
                        
                        $('#theme-purchase-title').textContent = `「${theme.name}」を交換しますか？`;
                        $('#theme-purchase-cost').textContent = `必要なポイント: ${theme.cost} LP`;
                        
                        // プレビュー表示
                        $('#theme-preview').style.backgroundColor = theme.color;
                
                        // ポイントが足りるかチェック
                        if (state.profile.lp >= theme.cost) {
                            confirmBtn.disabled = false;
                        } else {
                            confirmBtn.disabled = true;
                        }
                
                        confirmBtn.dataset.itemId = themeId;
                        confirmBtn.dataset.itemType = 'theme';
                        $('#theme-purchase-modal').style.display = 'flex';
                    }
                }

                const backgroundBtn = e.target.closest('.background-btn');
                if(backgroundBtn){
                    const bgId = backgroundBtn.dataset.bg;
                    if(state.profile.unlockedBackgrounds.includes(bgId)) {
                        state.profile.activeBackground = bgId;
                        saveState();
                        updateAppearance();
                        renderEngine.pages['settings-page']();
                        lucide.createIcons();
                    } else {
                        const bg = initialData.backgrounds[bgId];
                        const confirmBtn = $('#background-purchase-confirm');
                
                        $('#background-purchase-title').textContent = `「${bg.name}」を交換しますか？`;
                        $('#background-purchase-cost').textContent = `必要なポイント: ${bg.cost} LP`;
                
                        // プレビュー表示
                        const previewEl = $('#background-preview');
                        if (bg.url) {
                            previewEl.style.backgroundImage = `url(${bg.url})`;
                            previewEl.classList.remove('hidden');
                        } else {
                            previewEl.classList.add('hidden'); // デフォルトなど画像がない場合は非表示
                        }
                        
                        // ポイントが足りるかチェック
                        if (state.profile.lp >= bg.cost) {
                            confirmBtn.disabled = false;
                        } else {
                            confirmBtn.disabled = true;
                        }
                
                        confirmBtn.dataset.itemId = bgId;
                        confirmBtn.dataset.itemType = 'background';
                        $('#background-purchase-modal').style.display = 'flex';
                    }
                }

                const editCountdownBtn = e.target.closest('.edit-countdown-btn');
                if(editCountdownBtn){
                    const id = editCountdownBtn.dataset.id;
                    openCountdownModal(id);
                }

                // ▼▼▼ 集中モードボタン（タイマー/SW）のリスナー修正 ▼▼▼
                const focusModeBtn = e.target.closest('.focus-mode-btn');
                if(focusModeBtn) {
                    const mode = focusModeBtn.dataset.mode;
                    state.focus.mode = mode; // 'timer' か 'stopwatch' が入る
                    updateFocusModeUI(); // UIを更新
                }
                // ▲▲▲ 修正ここまで ▲▲▲

                // ▼▼▼ クエスト表示ボタンのリスナーを「新規追加」 ▼▼▼
                const showQuestBtn = e.target.closest('#show-quest-btn');
                if (showQuestBtn) {
                    $('#focus-main-view').style.display = 'none';
                    $('#quest-view').style.display = 'flex';
                    // クエストプランをレンダリング
                    renderQuestPlan();
                    lucide.createIcons();
                }

                // ▼▼▼ クエスト戻るボタンのリスナーを「新規追加」 ▼▼▼
                const questBackBtn = e.target.closest('#quest-back-btn');
                if (questBackBtn) {
                    $('#focus-main-view').style.display = 'flex';
                    $('#quest-view').style.display = 'none';
                    // 念のためタイマー/SWの表示を更新
                    updateFocusModeUI();
                }

                // 時間加算ボタンの処理
                const timeAddBtn = e.target.closest('.time-add-btn');
                if(timeAddBtn) {
                    const time = parseInt(timeAddBtn.dataset.time);
                    addTimerTime(time);
                }
                
                // リセットボタンの処理
                const timerResetBtn = e.target.closest('#timer-reset-btn');
                if(timerResetBtn) {
                    resetTimerDisplay();
                }
                // ★新規追加★ 休憩設定ボタン（クエスト中）
                const breakSettingsBtn = e.target.closest('#break-settings-btn');
                if (breakSettingsBtn) {
                    openBreakSettingsModal();
                }
    
                // ★新規追加★ 休憩設定モーダルを閉じる
                const breakSettingsCloseBtn = e.target.closest('#break-settings-close-btn');
                if (breakSettingsCloseBtn) {
                    $('#break-settings-modal').style.display = 'none';
                    // 変更を即座に反映
                    renderBreakIcons();
                }
            });
            
            /* 変更後 (新しいイベントリスナーとして追加) */
            $('#background-scope-toggle').addEventListener('change', (e) => {
                state.settings.backgroundScopeGlobal = e.target.checked;
                saveState();
                updateAppearance();
                updateBackgrounds();
                // 集中タブが表示されている場合に備えて再描画
                if ($('#focus-page').classList.contains('active')) {
                    renderEngine.pages['focus-page']();
                }
            });
            
            $('#lp-button').addEventListener('click', () => {
                // 1. LPポイントの表示を更新
                $('#modal-lp-display').textContent = state.profile.lp;
                
                // 2. テーマと壁紙のリストを描画（関数呼び出し）
                renderPointModalContent(); 
                
                // 3. モーダルを表示
                $('#point-details-modal').style.display = 'flex';
                lucide.createIcons();
            });

            function handlePurchase(e) {
                const { itemId, itemType } = e.target.dataset;
                
                // itemTypeは 'theme', 'background', 'game', 'music' のいずれか
                let dataList;
                let unlockList;

                if (itemType === 'theme') {
                    dataList = initialData.themes;
                    unlockList = state.profile.unlockedThemes;
                } else if (itemType === 'background') {
                    dataList = initialData.backgrounds;
                    unlockList = state.profile.unlockedBackgrounds;
                } else if (itemType === 'game') {
                    dataList = initialData.games;
                    unlockList = state.profile.unlockedGames;
                } else if (itemType === 'music') {
                    dataList = initialData.music;
                    unlockList = state.profile.unlockedMusic;
                }

                const itemData = dataList[itemId];
            
                if (state.profile.lp >= itemData.cost) {
                    addLP(-itemData.cost, `アイテム「${itemData.name}」交換`, false); // トースト重複回避のためfalse
                    unlockList.push(itemId);
                    showToast(`「${itemData.name}」を解放しました！`);
                    saveState();
                    if (itemType === 'game') {
                        syncGamesToBreakIcons();
                    }
                    renderPointModalContent(); // モーダル再描画
                    
                    // 設定ページが開かれていれば再描画
                    if ($('#settings-page').classList.contains('active')) {
                        renderEngine.pages['settings-page']();
                    }
                } else {
                    showToast('LPが足りません！');
                }
                
                // モーダルを閉じる
                $(`#${itemType}-purchase-modal`).style.display = 'none';
            }
            
            // --- Focus Page Logic ---
            const updateMiniTimer = () => {
                if (miniTimerTemporarilyHidden) {
                    $('#mini-timer-container').classList.remove('visible');
                    return;
                }
                const container = $('#mini-timer-container');
                const bar = $('#mini-timer-bar');
                if ((focusTimer.isRunning || stopwatch.isRunning) && !$('#focus-page').classList.contains('active')) {
                    container.classList.add('visible');
                    if(focusTimer.isRunning){
                        const progress = (focusTimer.defaultTime - focusTimer.timeLeft) / focusTimer.defaultTime * 100;
                        $('#mini-timer-text').textContent = formatTime(focusTimer.timeLeft);
                        $('#mini-timer-progress-bar').style.width = `${progress}%`;
                    } else { // stopwatch
                         $('#mini-timer-text').textContent = formatStopwatchTime(stopwatch.elapsedTime);
                         $('#mini-timer-progress-bar').style.width = `100%`;
                    }
                } else {
                    container.classList.remove('visible');
                }
            };
            
            const timerTick = () => {
                focusTimer.timeLeft--;
                $('#focus-timer-display').textContent = formatTime(focusTimer.timeLeft);
                updateMiniTimer();
                if (focusTimer.timeLeft <= 0) {
                    clearInterval(focusTimer.interval);
                    // showToast と new Notification は Service Worker が担当するためコメントアウトまたは削除
                    // showToast('集中モード完了！お疲れ様でした！');
                    // if (Notification.permission === 'granted') { ... }
            
                    const elapsed = focusTimer.defaultTime;
                    logStudyTime('focus', elapsed);
                    addLP(Math.floor(elapsed/60), 'タイマー完了');
                    state.focus.totalTime += elapsed;
                    saveState();
                    resetTimerUI();
            
                }
            };
            
            const stopwatchTick = () => {
                stopwatch.elapsedTime = (Date.now() - stopwatch.startTime) / 1000;
                $('#stopwatch-display').textContent = formatStopwatchTime(stopwatch.elapsedTime);
                updateMiniTimer();
            };

            const pauseFocusTimer = () => {
                if (!focusTimer.isRunning || focusTimer.isPaused) return;
                focusTimer.isPaused = true;
                clearInterval(focusTimer.interval);
                $('#focus-pause-btn').innerHTML = `<i data-lucide="play" class="w-6 h-6 mr-2"></i>再開`;
                lucide.createIcons();
            };

            const resumeFocusTimer = () => {
                if (!focusTimer.isRunning || !focusTimer.isPaused) return;
                focusTimer.isPaused = false;
                focusTimer.interval = setInterval(timerTick, 1000);
                $('#focus-pause-btn').innerHTML = `<i data-lucide="pause" class="w-6 h-6 mr-2"></i>一時停止`;
                lucide.createIcons();
            };

            const pauseStopwatch = () => {
                if (!stopwatch.isRunning || stopwatch.isPaused) return;
                stopwatch.isPaused = true;
                clearInterval(stopwatch.interval);
                $('#stopwatch-pause-btn').innerHTML = `<i data-lucide="play" class="w-6 h-6 mr-2"></i>再開`;
                lucide.createIcons();
            };

            const resumeStopwatch = () => {
                if (!stopwatch.isRunning || !stopwatch.isPaused) return;
                stopwatch.isPaused = false;
                stopwatch.startTime = Date.now() - stopwatch.elapsedTime * 1000;
                stopwatch.interval = setInterval(stopwatchTick, 100);
                $('#stopwatch-pause-btn').innerHTML = `<i data-lucide="pause" class="w-6 h-6 mr-2"></i>一時停止`;
                lucide.createIcons();
            };

            const updateFocusModeUI = () => {
                const mode = state.focus.mode;
                
                // メインビュー内の表示切替
                $('#timer-view').style.display = (mode === 'timer') ? 'flex' : 'none';
                $('#stopwatch-view').style.display = (mode === 'stopwatch') ? 'flex' : 'none';
    
                // ボタンのハイライト処理
                const timerBtn = $('.focus-mode-btn[data-mode="timer"]');
                const stopwatchBtn = $('.focus-mode-btn[data-mode="stopwatch"]');
                
                if (mode === 'timer') {
                    timerBtn.classList.add('primary-bg', 'text-white');
                    stopwatchBtn.classList.remove('primary-bg', 'text-white');
                } else if (mode === 'stopwatch') {
                    timerBtn.classList.remove('primary-bg', 'text-white');
                    stopwatchBtn.classList.add('primary-bg', 'text-white');
                }
            };

            // ▼▼▼ 新規追加: 背景画像を focus-view-bg クラスを持つ要素（クエスト含む）に適用する関数 ▼▼▼
            const updateBackgrounds = () => {
                const activeBgId = state.profile.activeBackground;
                const activeBg = initialData.backgrounds[activeBgId] || initialData.backgrounds['default'];
                const isGlobal = state.settings.backgroundScopeGlobal;
                const hasImage = activeBg && activeBg.url;
            
                // .focus-view-bg クラスを持つすべての要素（タイマー画面、クエスト画面など）を取得
                $$('.focus-view-bg').forEach(el => {
                    // 「全体適用」がオフで、かつ画像がある場合のみ、個別に背景を設定
                    // ※クエスト画面は全画面オーバーレイなので、GlobalがONでもOFFでも背景画像を表示したい場合は条件を調整
                    // ここでは「タイマー画面と同じ挙動（Global OFFなら個別に表示）」に加え、
                    // 「クエスト画面(#quest-active-screen)なら常に表示」というロジックにします。
                    
                    const isQuestScreen = el.id === 'quest-active-screen';
            
                    if ((!isGlobal && hasImage) || (isQuestScreen && hasImage)) {
                        el.style.backgroundImage = `url(${activeBg.url})`;
                    } else {
                        // 全体適用がONの場合は親(body)の背景が見えるので透明にする、または画像なし
                        el.style.backgroundImage = 'none';
                    }
                });
            };

            const resetTimerUI = () => {
                clearInterval(focusTimer.interval);
                focusTimer.isRunning = false; focusTimer.isPaused = false;
                focusTimer.timeLeft = focusTimer.defaultTime; // defaultTimeからリセット
                $('#focus-timer-display').textContent = formatTime(focusTimer.defaultTime);
                $('#focus-start-btn').classList.remove('hidden');
                $('#focus-controls').classList.add('hidden');
                $('#timer-settings-container').classList.remove('hidden');
                updateMiniTimer();
            };

            const resetStopwatchUI = () => {
                clearInterval(stopwatch.interval);
                stopwatch.isRunning = false; stopwatch.isPaused = false;
                stopwatch.elapsedTime = 0;
                $('#stopwatch-display').textContent = formatStopwatchTime(0);
                $('#stopwatch-start-btn').classList.remove('hidden');
                $('#stopwatch-controls').classList.add('hidden');
                updateMiniTimer();
            };

            const endFocusTimer = () => {
                if (!focusTimer.isRunning) return;
                const elapsed = focusTimer.defaultTime - focusTimer.timeLeft;
                if (elapsed > 0) { recordSession('タイマー', elapsed); addLP(Math.floor(elapsed / 60), 'タイマー'); state.focus.totalTime += elapsed; saveState(); }
                resetTimerUI();
            
                // 【追加】Service Workerにタイマー停止を通知
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({ command: 'focusTimer_stop' });
                }
                // ▼▼▼【追加】ここから▼▼▼
                state.focus.isRunning = false;
                state.focus.startTime = null;
                saveState();
                // ▲▲▲【追加】ここまで▲▲▲
            };

            const endStopwatch = () => {
                if (!stopwatch.isRunning) return;
                const elapsed = Math.round(stopwatch.elapsedTime);
                if (elapsed > 0) { recordSession('ストップウォッチ', elapsed); addLP(Math.floor(elapsed / 60), 'ストップウォッチ'); state.focus.totalTime += elapsed; saveState(); }
                resetStopwatchUI();
                // ▼▼▼【追加】ここから▼▼▼
                state.focus.isRunning = false;
                state.focus.startTime = null;
                saveState();
                // ▲▲▲【追加】ここまで▲▲▲
            };
            
            const setTimer = (seconds) => {
                focusTimer.defaultTime = seconds; // defaultTimeも更新
                focusTimer.timeLeft = seconds;
                $('#focus-timer-display').textContent = formatTime(seconds);
            };

           $('#focus-start-btn').addEventListener('click', () => {
                if (focusTimer.timeLeft <= 0) {
                    showToast('時間を設定してください');
                    return;
                }
                focusTimer.defaultTime = focusTimer.timeLeft;
                focusTimer.isRunning = true;
                focusTimer.isPaused = false;
                state.focus.isRunning = true;
                state.focus.startTime = Date.now(); // 現在時刻のタイムスタンプを保存
                state.focus.duration = focusTimer.timeLeft;
                saveState();
                focusTimer.interval = setInterval(timerTick, 1000);
                $('#focus-start-btn').classList.add('hidden');
                $('#focus-controls').classList.remove('hidden');
                $('#timer-settings-container').classList.add('hidden');
                updateMiniTimer();
            
                // 【追加】Service Workerにタイマー開始を通知
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        command: 'focusTimer_start', // ★ 'startTimer' から変更
                        timeLeft: focusTimer.timeLeft,
                        title: '⌛タイマー終了', // ★ 通知タイトルを追加
                        body: 'お疲れ様でした！タイマーが終了しました。' // ★ 通知本文を追加
                    });
                }
            });
            /* ▼▼▼ 追加: クエスト機能のイベントリスナー ▼▼▼ */

            // クエスト設定ビューのボタン
            addSectionBtn.addEventListener('click', () => {
                quest.plan.push({
                    id: Date.now(),
                    type: 'section',
                    text: '新しいセクション',
                    duration: 25 * 60
                });
                renderQuestPlan();
            });

            addBreakBtn.addEventListener('click', () => {
                quest.plan.push({
                    id: Date.now(),
                    type: 'break',
                    duration: 5 * 60
                });
                renderQuestPlan();
            });

            addBreaksBtn.addEventListener('click', () => {
                const interval = parseInt($('#break-interval-input').value) || 2;
                const duration = parseInt($('#break-duration-input').value) || 5;
                const newPlan = [];
                let sectionCount = 0;
                
                // 休憩を除いたセクションのみのリストを元にする
                const sections = quest.plan.filter(item => item.type === 'section');

                sections.forEach((item, index) => {
                    newPlan.push(item);
                    sectionCount++;
                    // 最後のセクション以外で、intervalの倍数番目なら休憩を追加
                    if (sectionCount % interval === 0 && index !== sections.length - 1) {
                        newPlan.push({
                            id: Date.now() + Math.random(),
                            type: 'break',
                            duration: duration * 60
                        });
                    }
                });
                
                quest.plan = newPlan;
                renderQuestPlan();
            });

            startQuestBtn.addEventListener('click', startQuest);

            // クエスト実行画面のボタン
            endQuestBtn.addEventListener('click', () => {
                confirmationModal.style.display = 'flex';
            });

            modalConfirmBtn.addEventListener('click', () => endQuest(false));
            modalCancelBtn.addEventListener('click', () => {
                confirmationModal.style.display = 'none';
            });

           // 休憩中のコンテンツ (アイコンホーム画面)
            if(breakIconGrid) {
                breakIconGrid.addEventListener('click', (e) => {
                    const btn = e.target.closest('.break-content-btn');
                    if (btn && btn.dataset.url) {
                        // ★ここから変更★
                        if (btn.dataset.openMode === 'external') {
                            // 外部タブで開く (強制クローズ不可)
                            window.open(btn.dataset.url, '_blank');
                        } else {
                            // 従来通りアプリ内 (iframe) で開く (強制クローズ可能)
                            openIframe(btn.dataset.url);
                        }
                        // ★ここまで変更★
                    }
                });
            }
            closeIframeBtn.addEventListener('click', closeIframe);

            /* ▲▲▲ 追加: クエスト機能のイベントリスナー ▲▲▲ */
            
            $('#focus-pause-btn').addEventListener('click', () => { if (focusTimer.isPaused) resumeFocusTimer(); else pauseFocusTimer(); });
            $('#focus-end-btn').addEventListener('click', endFocusTimer);

            $('#stopwatch-start-btn').addEventListener('click', () => {
                stopwatch.isRunning = true; stopwatch.isPaused = false;
                // 修正：保存された時間ではなく、常に現在の時刻から開始
                stopwatch.startTime = Date.now() - stopwatch.elapsedTime * 1000;
            
                // ▼▼▼【追加】ここから▼▼▼
                state.focus.isRunning = true;
                // ストップウォッチの場合、開始時刻のみ保存
                state.focus.startTime = stopwatch.startTime; 
                saveState();
                stopwatch.interval = setInterval(stopwatchTick, 100);
                $('#stopwatch-start-btn').classList.add('hidden');
                $('#stopwatch-controls').classList.remove('hidden');
                updateMiniTimer();
            });
            $('#stopwatch-pause-btn').addEventListener('click', () => { if (stopwatch.isPaused) resumeStopwatch(); else pauseStopwatch(); });
            $('#stopwatch-end-btn').addEventListener('click', endStopwatch);
            
            $('#notification-permission-btn').addEventListener('click', async () => {
                if (!('Notification' in window)) { showToast('お使いのブラウザは通知に対応していません。'); return; }
                const permission = await Notification.requestPermission();
                if (permission === 'granted') { showToast('通知が許可されました！'); new Notification('StudyQuestへようこそ！', { body: '通知設定がオンになりました。' }); $('#notification-settings-card').style.display = 'none';} 
                else { showToast('通知が拒否されました。端末の設定アプリから変更できます。'); }
            });
            
            // ▼▼▼ 修正版: アニメーション付きタブ切り替え処理（描画遅延対応） ▼▼▼
            let isAnimating = false;

            $$('.tab-btn').forEach(btn => btn.addEventListener('click', e => {
                const nextPageId = e.currentTarget.dataset.page;
                const activePage = document.querySelector('.page.active');
                
                if ((activePage && activePage.id === nextPageId) || isAnimating) return;

                const nextPage = $(`#${nextPageId}`);
                if (!nextPage) return;

                // 1. まずUI（ボタン）を即座に更新
                $$('.tab-btn').forEach(b => b.classList.replace('primary-text', 'text-gray-500'));
                e.currentTarget.classList.replace('text-gray-500', 'primary-text');
                $('#header-title').textContent = e.currentTarget.dataset.title;

                isAnimating = true;

                // 2. 現在のページがあれば「退出」開始
                if (activePage) {
                    activePage.classList.add('page-exit');
                    activePage.classList.remove('active');
                    
                    activePage.addEventListener('animationend', () => {
                        activePage.classList.remove('page-exit');
                    }, { once: true });
                }

                // 3. 次のページに「進入」クラスを付与（アニメーション開始）
                nextPage.classList.add('page-enter');

                // 4. 【重要】描画処理を少しだけ遅らせる
                // これにより、ブラウザが「アニメーションの開始フレーム」を描画しきってから
                // 重い処理（グラフ描画など）が走るため、ガタつきが軽減される。
                requestAnimationFrame(() => {
                    setTimeout(() => {
                        // ページ固有のレンダリング（グラフ描画など）
                        if (renderEngine.pages[nextPageId]) { 
                            renderEngine.pages[nextPageId](); 
                        }

                        // 集中モード等のUI更新
                        if (nextPageId === 'focus-page') {
                            miniTimerTemporarilyHidden = false;
                        }
                        updateMiniTimer();
                        lucide.createIcons();

                    }, 10); // 10ms程度の遅延で十分効果あり
                });

                // 5. アニメーション終了時の処理
                nextPage.addEventListener('animationend', () => {
                    nextPage.classList.remove('page-enter');
                    nextPage.classList.add('active');
                    isAnimating = false;
                }, { once: true });

            }));
            // ▲▲▲ 修正ここまで ▲▲▲

            $('#mini-timer-bar').addEventListener('click', (e) => {
                if (e.target.closest('#close-mini-timer-btn')) return;
                document.querySelector('.tab-btn[data-page="focus-page"]').click();
            });

            $('#close-mini-timer-btn').addEventListener('click', () => {
                miniTimerTemporarilyHidden = true; // フラグを立てる
                $('#mini-timer-container').classList.remove('visible'); // 非表示にする
            });

            // --- Countdown Logic ---
            function openCountdownModal(id = null) {
                const modal = $('#countdown-modal');
                modal.dataset.editingId = id || '';
                const title = $('#countdown-modal-title');
                const deleteBtn = $('#countdown-delete-btn');
                const nameInput = $('#countdown-name');
                const dateInput = $('#countdown-date');
            
                if (id) {
                    title.textContent = 'カウントダウンの編集';
                    deleteBtn.classList.remove('hidden');
                    const countdown = state.countdowns.find(c => c.id === id);
                    nameInput.value = countdown.name;
                    dateInput.value = countdown.date;
                    
                } else {
                    title.textContent = 'カウントダウンの追加';
                    deleteBtn.classList.add('hidden');
                    nameInput.value = '';
                    
                    const defaultDate = new Date();
                    defaultDate.setDate(defaultDate.getDate() + 14);
                    dateInput.value = defaultDate.toISOString().split('T')[0];

                }

                modal.style.display = 'flex';
                lucide.createIcons();

            }

            function saveCountdown() {
                const id = $('#countdown-modal').dataset.editingId;
                const name = $('#countdown-name').value.trim();
                const date = $('#countdown-date').value;

                if (!name || !date) {
                    showToast('イベント名と日付を入力してください');
                    return;
                }

                const countdownData = {
                    name,
                    date,
                };

                if (id) {
                    const index = state.countdowns.findIndex(c => c.id === id);
                    state.countdowns[index] = { ...state.countdowns[index], ...countdownData };
                } else {
                    countdownData.id = `cd_${Date.now()}`;
                    state.countdowns.push(countdownData);
                }

                state.countdowns.sort((a, b) => new Date(a.date) - new Date(b.date));
                saveState();
                renderEngine.pages['home-page']();
                lucide.createIcons();
                $('#countdown-modal').style.display = 'none';
            }
            
            function deleteCountdown() {
                // 確認ダイアログを追加
                if (!confirm('本当にこのカウントダウンを削除してもよろしいですか？')) {
                    return; // キャンセルされたら、ここで処理を終了
                }
            
                const id = $('#countdown-modal').dataset.editingId;
                state.countdowns = state.countdowns.filter(c => c.id !== id);
                saveState();
                renderEngine.pages['home-page']();
                lucide.createIcons();
                $('#countdown-modal').style.display = 'none';
            }

            /* ▼▼▼ 追加: クエスト機能の関数群 ▼▼▼ */

        // クエストプランのリストをレンダリングする関数
        function renderQuestPlan() {
            questPlanListEl.innerHTML = '';
            if (quest.plan.length === 0) {
                questPlanListEl.innerHTML = `<p class="text-center text-sm text-gray-500">「今日の予定」を読み込むか、<br>「セクション追加」を押してください。</p>`;
            }
            let sectionCounter = 1; 
            
            quest.plan.forEach((item, index) => {
                const itemEl = document.createElement('div');
                // ★スワイプ用クラス追加
                itemEl.className = 'swipe-container relative overflow-hidden rounded-lg mb-2';
                
                let contentHTML = '';
                if (item.type === 'section') {
                    contentHTML = `
                        <span class="font-bold w-6 text-center shrink-0">${sectionCounter}</span>
                        <input type="text" value="${item.text}" data-original-id="${item.originalTaskId || ''}" class="quest-item-text flex-grow bg-transparent p-1 rounded border border-transparent focus:border-gray-400 dark:focus:border-gray-500 focus:outline-none min-w-0 truncate">
                        <input type="number" value="${item.duration / 60}" class="quest-item-duration w-12 p-1 border rounded text-center dark:bg-gray-600 dark:border-gray-500 shrink-0">
                        <span class="text-sm shrink-0">分</span>
                    `;
                    sectionCounter++;
                } else { // break
                    contentHTML = `
                        <span class="font-bold w-6 text-center shrink-0">☕</span>
                        <span class="flex-grow p-1 text-gray-500 dark:text-gray-400 font-semibold">ブレイクタイム</span>
                        <input type="number" value="${item.duration / 60}" class="quest-item-duration w-12 p-1 border rounded text-center dark:bg-gray-600 dark:border-gray-500 shrink-0">
                        <span class="text-sm shrink-0">分</span>
                    `;
                }

                itemEl.innerHTML = `
                    <div class="swipe-actions">
                         <div style="width:100%; flex:1;"></div> <button class="btn-delete swipe-btn bg-red-500 w-[70px]">
                            <i data-lucide="trash-2" class="w-6 h-6"></i>
                            <span>削除</span>
                        </button>
                    </div>

                    <div class="swipe-content flex items-center space-x-2 bg-gray-100 dark:bg-gray-800 p-2 relative z-10 w-full">
                        ${contentHTML}
                        <button class="quest-handle cursor-move text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-opacity shrink-0 p-1">
                            <i data-lucide="grip-vertical" class="w-5 h-5"></i>
                        </button>
                    </div>
                `;
                
                questPlanListEl.appendChild(itemEl);

                // ★スワイプ適用
                new SwipeHandler(itemEl, {
                    onDelete: () => {
                        quest.plan = quest.plan.filter(p => p.id !== item.id);
                        // 配列操作後に少し待ってから再描画（アニメーション待ち）
                        setTimeout(renderQuestPlan, 300);
                    }
                });

                // イベントリスナー（変更なし）
                itemEl.querySelector('.quest-item-text')?.addEventListener('change', (e) => {
                    item.text = e.target.value;
                    item.originalTaskId = e.target.dataset.originalId || null;
                });
                itemEl.querySelector('.quest-item-duration').addEventListener('change', (e) => {
                    item.duration = parseInt(e.target.value) * 60;
                });
            });
            lucide.createIcons();
        };
            
        // クエスト用のタイマーを開始する関数 (バックグラウンド耐性強化版)
        function startQuestTimer(duration, onTick, onEnd) {
            // 1. 既存のインターバルをクリア
            if (quest.timerInterval) {
                clearInterval(quest.timerInterval);
            }
            
            // 2. このステップの「絶対的な終了時刻」を計算
            const endTime = Date.now() + duration * 1000;

            // 2.5. 呼び出し直後に、まずUIを現在の時間で更新する
            const initialTimeLeft = Math.max(0, Math.floor((endTime - Date.now()) / 1000));
            onTick(initialTimeLeft);
            quest.timeLeft = initialTimeLeft;

            // 3. 1秒ごとにチェックするインターバルを開始
            quest.timerInterval = setInterval(() => {
                const now = Date.now();
                // 4. 終了時刻と現在時刻から、本当の残り時間を計算 (0秒未満にはしない)
                const timeLeft = Math.max(0, Math.floor((endTime - now) / 1000));

                // 5. ログ記録用に、グローバルの残り時間を更新
                quest.timeLeft = timeLeft; 
                
                // 6. UIを更新 (onTick)
                onTick(timeLeft);

                // 7. 終了時刻を過ぎていたら、タイマーを停止して onEnd を呼ぶ
                if (now >= endTime) {
                    clearInterval(quest.timerInterval);
                    quest.timerInterval = null;
                    onEnd(); // 終了コールバック
                }
            }, 1000); // 1秒ごとにチェック (厳密には100ms等の方が精度は良いが、1000msでも十分)
        };

        function cancelQuestAlarm() {
            if (navigator.serviceWorker.controller) {
                // 'stopTimer' コマンドを (集中モードと) 共有して使用
                navigator.serviceWorker.controller.postMessage({
                    command: 'questTimer_stop' 
                });
            }
        }

        function sendQuestAlarm(durationInSeconds, title, body) {
            if (Notification.permission === "granted" && navigator.serviceWorker.controller) {
                // 'startTimer' コマンドを (集中モードと) 共有して使用
                navigator.serviceWorker.controller.postMessage({
                    command: 'questTimer_start', 
                    timeLeft: durationInSeconds,
                    title: title, // 通知のタイトル
                    body: body  // 通知の本文
                });
            }
        }

        // ▼▼▼ 新規・修正: クエスト進行ロジック（確認画面付き） ▼▼▼

            const questTransitionView = $('#quest-transition-view');
            const transitionTitle = $('#transition-title');
            const transitionMessage = $('#transition-message');
            const transitionNextText = $('#transition-next-text');
            const transitionNextDuration = $('#transition-next-duration');
            const transitionStartBtn = $('#transition-start-btn');
            const transitionIcon = $('#transition-icon');

            // 次のステップへ進む準備
            function runNextQuestStep() {
                quest.currentIndex++;
                
                // 全ステップ終了時の処理
                if (quest.currentIndex >= quest.plan.length) {
                    endQuest(true);
                    return;
                }

                const nextStep = quest.plan[quest.currentIndex];

                // ★追加: クエストの状態を保存 (現在地と開始時刻を記録)
                state.savedQuest = {
                    plan: quest.plan,
                    currentIndex: quest.currentIndex,
                    startTime: Date.now(), // このステップの開始時刻（仮）
                    active: true
                };
                saveState();

                // 最初のステップは即開始し、それ以降は確認画面を出す
                if (quest.currentIndex === 0) {
                    executeQuestStep(nextStep);
                } else {
                    showTransitionScreen(nextStep);
                }
            }

            // トランジション（待機）画面を表示
            function showTransitionScreen(step) {
                // 前の画面を隠す
                questSectionView.style.display = 'none';
                questBreakView.style.display = 'none';
                $('#break-settings-btn').classList.add('hidden');

                // トランジション画面を表示
                questTransitionView.style.display = 'flex';
                
                // 内容のセット
                if (step.type === 'section') {
                    transitionTitle.textContent = "学習を始めますか？";
                    transitionMessage.textContent = "準備ができたらスタートボタンを押してください。";
                    transitionIcon.setAttribute('data-lucide', 'book-open');
                    transitionNextText.textContent = step.text;
                    transitionNextDuration.textContent = `${step.duration / 60} 分`;
                    transitionStartBtn.className = "primary-bg primary-bg-hover text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:scale-105 transition-transform flex items-center";
                } else {
                    transitionTitle.textContent = "休憩タイム";
                    transitionMessage.textContent = "お疲れ様でした！少し頭を休めましょう。";
                    transitionIcon.setAttribute('data-lucide', 'coffee');
                    transitionNextText.textContent = "ブレイクタイム";
                    transitionNextDuration.textContent = `${step.duration / 60} 分`;
                    transitionStartBtn.className = "bg-green-600 hover:bg-green-700 text-white text-xl font-bold py-4 px-12 rounded-full shadow-lg hover:scale-105 transition-transform flex items-center";
                }

                lucide.createIcons();

                // スタートボタンのイベント（一度だけ発火するように設定）
                transitionStartBtn.onclick = () => {
                    questTransitionView.style.display = 'none';
                    executeQuestStep(step);
                };
            }

            // 実際のタイマー画面を表示して開始
            function executeQuestStep(currentStep) {
                cancelQuestAlarm();

                // ★追加: 実際にタイマーが動くタイミングで正確な開始時刻を保存
                if(state.savedQuest) {
                    state.savedQuest.startTime = Date.now();
                    // currentStepが休憩かセクションか区別して保存しても良いが、
                    // 復元時に計算するので最低限 Date.now() があればOK
                    saveState();
                }

                // アプリ2のトースト関数とNotification APIを使用
                const showQuestNotification = (title, body) => {
                    showToast(body);
                    if (Notification.permission === "granted" && navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage({
                            command: 'showQuestNotification',
                            title: title,
                            body: body
                        });
                    }
                };

                if (currentStep.type === 'section') {
                    playBGM();
                    questSectionView.style.display = 'flex';
                    questBreakView.style.display = 'none';
                    $('#break-settings-btn').classList.add('hidden');
                    
                    questSectionTitle.textContent = currentStep.text;
                    // 進捗表示
                    const totalSections = quest.plan.filter(p => p.type === 'section').length;
                    const currentSectionNumber = quest.plan.slice(0, quest.currentIndex + 1).filter(p => p.type === 'section').length;
                    questProgressEl.textContent = `${currentSectionNumber} / ${totalSections}`;

                    // ★ここでSWに「予約」を入れているので、時間になれば自動で通知が来ます
                    sendQuestAlarm(
                        currentStep.duration,
                        '🔥セクション終了',
                        'お疲れ様でした！'
                    );
                    
                    startQuestTimer(
                        currentStep.duration,
                        (timeLeft) => { questTimerEl.textContent = formatTime(timeLeft); },
                        () => {
                            // --- ▼▼▼ 修正箇所 1 ▼▼▼ ---
                            // ここで showQuestNotification を呼ぶと「今すぐ通知」が送られて重複します。
                            // 代わりに showToast だけ呼んで、画面内のメッセージだけ表示します。
                            const elapsed = currentStep.duration;
                            if (elapsed > 0) {
                                recordSession(currentStep.text, elapsed);
                                addLP(Math.floor(elapsed / 60), 'クエストセクション');
                                state.focus.totalTime += elapsed;
                                
                                if (currentStep.originalTaskId) {
                                    const taskId = parseInt(currentStep.originalTaskId);
                                    const taskIndex = state.tasks.findIndex(t => t.id === taskId);
                                    if (taskIndex !== -1) {
                                        state.tasks[taskIndex].completed = true;
                                    }
                                }
                                saveState();
                            }
                            // ★通知はSWの予約に任せ、ここではトーストのみ表示
                            showToast('お疲れ様でした！'); 
                            // --- ▲▲▲ 修正ここまで ▲▲▲ ---

                            runNextQuestStep(); // 次（トランジション画面）へ
                        }
                    );
                } else { // break
                    pauseBGM();
                    questSectionView.style.display = 'none';
                    questBreakView.style.display = 'flex';
                    $('#break-settings-btn').classList.remove('hidden');
                    renderBreakIcons();

                    // ★ここでSWに「予約」を入れています
                    sendQuestAlarm(
                        currentStep.duration,
                        '☕ブレイクタイム終了',
                        '休憩時間が終わりました。'
                    );
                    
                    startQuestTimer(
                        currentStep.duration,
                        (timeLeft) => {
                            breakTimerEl.textContent = formatTime(timeLeft);
                            // 残り30秒の通知は「予約」していないので、ここから送ってもOK（重複しない）
                            if (timeLeft === 30) {
                                showQuestNotification('⏱まもなく休憩終了', '30秒後に終了します。');
                            }
                        },
                        () => {
                            // --- ▼▼▼ 修正箇所 2 ▼▼▼ ---
                            // ここも同様に修正
                            // showQuestNotification('休憩終了', '休憩が終わりました。'); 
                            showToast('休憩が終わりました。');
                            // --- ▲▲▲ 修正ここまで ▲▲▲ ---

                            closeIframe();
                            runNextQuestStep(); // 次（トランジション画面）へ
                        }
                    );
                }
                lucide.createIcons();
            }
            // ▲▲▲ クエスト進行ロジック修正完了 ▲▲▲

        // クエストを開始する関数
        function startQuest() {
            if (quest.plan.length === 0) {
                showToast('クエストの予定がありません。');
                return;
            }
            quest.active = true;
            quest.currentIndex = -1;
            updateBackgrounds();
            questActiveScreen.style.display = 'flex';
            
            // アプリ2のヘッダーとタブバーを隠す
            $('header').style.display = 'none';
            $('nav').style.display = 'none';
            $('#mini-timer-container').classList.remove('visible'); // ミニタイマーも隠す

            document.body.style.overflow = 'hidden';
            runNextQuestStep();
        };

        // クエストを終了する関数
        function endQuest(completed = false) {
            state.savedQuest = null;
            saveState();
            stopBGM();
            $('#break-settings-btn').classList.add('hidden');
            clearInterval(quest.timerInterval);
            quest.timerInterval = null; // 忘れずにクリア

            // --- ★追加★ クエスト終了時にSWのアラームをキャンセルする ---
            cancelQuestAlarm();
            if (!completed && quest.currentIndex >= 0 && quest.currentIndex < quest.plan.length) {
                const currentStep = quest.plan[quest.currentIndex];
                // 現在のステップが 'section' (学習中) の場合のみ記録
                if (currentStep.type === 'section') {
                    const elapsed = currentStep.duration - quest.timeLeft; // 経過時間
                    if (elapsed > 0) {
                        recordSession(`${currentStep.text} (中断)`, elapsed);
                        addLP(Math.floor(elapsed / 60), 'クエスト（中断）');
                        state.focus.totalTime += elapsed;
                        saveState();
                        showToast(`セクションの ${formatTime(elapsed)} を記録しました。`);
                    }
                }
            }
            
            quest.active = false;
            questActiveScreen.style.display = 'none';

            // アプリ2のヘッダーとタブバーを再表示
            $('header').style.display = 'flex';
            $('nav').style.display = 'flex';

            document.body.style.overflow = 'auto';
            confirmationModal.style.display = 'none';
            closeIframe();
            if (completed) {
                showToast('クエスト完了！お疲れ様でした！');
            }
        };

        // 休憩用iframeを開く関数（ローディング制御付き）
        function openIframe(url) {
            const iframe = $('#break-iframe');
            const overlay = $('#iframe-overlay');
            const loader = $('#iframe-loader');
        
            // 初期状態：iframeを透明にし、ローダーを表示
            iframe.classList.remove('opacity-100');
            iframe.classList.add('opacity-0');
            loader.style.display = 'flex';
            
            overlay.style.display = 'flex'; // オーバーレイ表示
        
            // URLセット
            iframe.src = url;
        
            // 読み込み完了時のイベント
            iframe.onload = () => {
                loader.style.display = 'none'; // ローダーを隠す
                iframe.classList.remove('opacity-0');
                iframe.classList.add('opacity-100'); // フェードイン
            };
            
            lucide.createIcons();
        };
        
        function closeIframe() {
            const iframe = $('#break-iframe');
            const overlay = $('#iframe-overlay');
            
            iframe.src = 'about:blank';
            iframe.classList.remove('opacity-100');
            iframe.classList.add('opacity-0');
            overlay.style.display = 'none';
        };
            
        // ★修正後★ 休憩アイコンをレンダリングする関数
        function renderBreakIcons() {
            if (!breakIconGrid) return;

            // 1. 表示がオンのアイコンだけを抽出
            const items = state.breakIcons.filter(icon => icon.visible);

            // 2. HTMLを生成
            breakIconGrid.innerHTML = items.map(icon => `
                <button class="break-content-btn" data-url="${icon.url}" data-open-mode="${icon.openMode || 'external'}" data-id="${icon.id}">
                    <i data-lucide="${icon.icon}" class="w-8 h-8 mb-1"></i>
                    <span>${icon.name}</span>
                </button>
            `).join('');
            
            lucide.createIcons();
        }

        // ★新規追加★ 解禁済みゲームをbreakIconsに同期させる関数
        function syncGamesToBreakIcons() {
            state.profile.unlockedGames.forEach(gameId => {
                // すでにbreakIconsにあるかチェック
                const exists = state.breakIcons.find(icon => icon.id === gameId);
                
                if (!exists) {
                    const game = initialData.games[gameId];
                    if (game) {
                        // 新しくbreakIconsに追加 (デフォルトで表示ON)
                        state.breakIcons.push({
                            id: gameId,
                            name: game.name,
                            icon: game.icon,
                            url: game.url,
                            openMode: 'iframe', // ゲームはiframeで開く
                            type: 'game',
                            visible: true
                        });
                    }
                }
            });
            // 保存
            saveState();
        }

        // ★修正後★ 休憩設定モーダルの中身を描画する関数
        function renderBreakSettingsModal() {
            const activeContainer = $('#break-active-list');
            const inactiveContainer = $('#break-inactive-list');
            
            if (!activeContainer || !inactiveContainer) return;
        
            activeContainer.innerHTML = '';
            inactiveContainer.innerHTML = '';
        
            // 1. アイコンを表示中と非表示に分ける
            const activeIcons = state.breakIcons.filter(i => i.visible);
            const inactiveIcons = state.breakIcons.filter(i => !i.visible);
        
            // 2. 表示中リストの描画 (削除ボタン付き)
            if (activeIcons.length === 0) {
                activeContainer.innerHTML = '<p class="text-xs text-gray-500 text-center py-2">表示するコンテンツがありません</p>';
            } else {
                activeContainer.innerHTML = activeIcons.map(icon => `
                    <div class="break-settings-item flex items-center bg-white/5 p-3 rounded-lg border border-white/10 mb-2 touch-none" data-id="${icon.id}">
                        <div class="break-settings-handle p-2 mr-1 cursor-grab active:cursor-grabbing text-gray-400">
                             <i data-lucide="grip-vertical" class="w-6 h-6"></i>
                        </div>
                        <div class="flex items-center justify-center w-8 h-8 mr-3 text-gray-200">
                            <i data-lucide="${icon.icon}" class="w-6 h-6"></i>
                        </div>
                        <span class="text-gray-200 flex-grow text-sm font-bold truncate">${icon.name}</span>
                        <button class="remove-break-btn p-2 rounded-full text-red-400 hover:bg-red-500/20 transition flex-shrink-0">
                            <i data-lucide="minus-circle" class="w-5 h-5"></i>
                        </button>
                    </div>
                `).join('');
            }
        
            // 3. 追加可能リストの描画 (追加ボタン付き)
            if (inactiveIcons.length === 0) {
                inactiveContainer.innerHTML = '<p class="text-xs text-gray-500 w-full text-center">すべて追加済みです</p>';
            } else {
                inactiveContainer.innerHTML = inactiveIcons.map(icon => `
                    <button class="add-break-btn flex items-center space-x-2 bg-white/5 hover:bg-white/10 border border-white/10 px-3 py-2 rounded-full transition" data-id="${icon.id}">
                        <i data-lucide="plus" class="w-4 h-4 text-green-400"></i>
                        <span class="text-sm text-gray-300">${icon.name}</span>
                    </button>
                `).join('');
            }
        
            // ★アイコンを確実に生成（対象コンテナを指定）
            lucide.createIcons({ root: activeContainer });
            lucide.createIcons({ root: inactiveContainer });
        
            // 4. イベントリスナー設定：削除ボタン
            activeContainer.querySelectorAll('.remove-break-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const itemId = e.target.closest('.break-settings-item').dataset.id;
                    const icon = state.breakIcons.find(i => i.id === itemId);
                    if (icon) {
                        icon.visible = false;
                        saveState();
                        renderBreakSettingsModal(); // 再描画
                        renderBreakIcons(); // 親画面も更新
                    }
                });
            });
        
            // 5. イベントリスナー設定：追加ボタン
            inactiveContainer.querySelectorAll('.add-break-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const itemId = btn.dataset.id;
                    const icon = state.breakIcons.find(i => i.id === itemId);
                    if (icon) {
                        icon.visible = true;
                        saveState();
                        renderBreakSettingsModal(); // 再描画
                        renderBreakIcons(); // 親画面も更新
                    }
                });
            });
        
            // 6. Sortable.js の適用 (重複防止ロジック追加)
            // 以前のインスタンスがあれば破棄する
            if (breakSortable) {
                breakSortable.destroy();
            }

            // 新しく作成する
            breakSortable = Sortable.create(activeContainer, {
                handle: '.break-settings-handle',
                animation: 150,
                ghostClass: 'sortable-ghost',
                delay: 100, // 少しだけ長押し判定を入れるとスクロールと干渉しにくい
                delayOnTouchOnly: true,
                touchStartThreshold: 5,
                onEnd: (evt) => {
                    // 並び替え後のID順序を取得
                    const idOrder = Array.from(activeContainer.children).map(child => child.dataset.id);
                    
                    // state.breakIcons を並び替える
                    const sortedActive = idOrder.map(id => state.breakIcons.find(i => i.id === id)).filter(Boolean); // filter(Boolean)でundefined排除
                    const inactive = state.breakIcons.filter(i => !i.visible);
                    
                    state.breakIcons = [...sortedActive, ...inactive];
                    saveState();
                    renderBreakIcons(); // 親画面の並び順も更新
                }
            });
        }
            
        // ★新規追加★ 休憩設定モーダルを開く関数
        function openBreakSettingsModal() {
            renderBreakSettingsModal(); // 1. 中身を描画
            $('#break-settings-modal').style.display = 'flex'; // 2. モーダルを表示
        }

        /* ▲▲▲ 追加: クエスト機能の関数群 ▲▲▲ */
        
            
            const restoreFocusState = () => {
            // 保存された実行中のタイマー/SWがなければ何もしない
            if (!state.focus.isRunning || !state.focus.startTime) {
                setTimer(1800);
                return;
            }
        
            const elapsed = Math.floor((Date.now() - state.focus.startTime) / 1000); // 経過時間（秒）
        
            // 復元するモードに合わせてUIを更新
            updateFocusModeUI();
        
            if (state.focus.mode === 'timer') {
                const timeLeft = state.focus.duration - elapsed;
        
                if (timeLeft <= 0) {
                    // 復元時にはタイマーが既に終了している場合
                    showToast('アプリを閉じている間にタイマーが終了しました');
                    new Notification('StudyQuest', { body: '集中タイマーが終了していました。' }); // 通知も出す
                    recordSession('タイマー', state.focus.duration);
                    addLP(Math.floor(state.focus.duration / 60), 'タイマー完了');
                    resetTimerUI();
                    // 状態をクリア
                    state.focus.isRunning = false;
                    state.focus.startTime = null;
                    saveState();
                    setTimer(1800); // 次のためにリセット
                } else {
                    // タイマーを復元
                    focusTimer.timeLeft = timeLeft;
                    focusTimer.defaultTime = state.focus.duration;
                    focusTimer.isRunning = true;
        
                    $('#focus-timer-display').textContent = formatTime(timeLeft);
                    $('#focus-start-btn').classList.add('hidden');
                    $('#focus-controls').classList.remove('hidden');
                    $('#timer-settings-container').classList.add('hidden');
        
                    focusTimer.interval = setInterval(timerTick, 1000);
                    updateMiniTimer();
                }
            } else { // ストップウォッチの場合
                stopwatch.elapsedTime = elapsed;
                stopwatch.startTime = state.focus.startTime;
                stopwatch.isRunning = true;
        
                $('#stopwatch-display').textContent = formatStopwatchTime(elapsed);
                $('#stopwatch-start-btn').classList.add('hidden');
                $('#stopwatch-controls').classList.remove('hidden');
        
                stopwatch.interval = setInterval(stopwatchTick, 100);
                updateMiniTimer();
            }
        };

            // ==========================================
            // ▼▼▼ 新規追加: ユーザー登録・移行ロジック ▼▼▼
            // ==========================================

            // 1. アプリ起動時の分岐処理 (init関数の最後で呼ぶ)
            const checkUserRegistration = () => {
                const splash = document.getElementById('splash-screen');
                
                if (!state.user.isRegistered) {
                    $('#app-container').classList.add('hidden');
                    
                } else {
                    // 登録済みなら通常通り
                    $('#app-container').classList.remove('hidden');
                    // 既存のスプラッシュフェードアウト処理に任せる
                }
            };

            // 2. イベントリスナー設定
            
            // Welcome画面
            $('#btn-start-new').addEventListener('click', () => {
                $('#welcome-screen').classList.add('hidden');
                $('#registration-screen').classList.remove('hidden');
            });
            
            $('#btn-transfer-start').addEventListener('click', () => {
                openMigrationModal(true);
            });

            // 登録画面
            const emojis = ['🎓','✏️','🔥','🐱','🐶','🚀','⭐','🍎','⚽','🎵','🎨','💻'];
            const getRandomEmoji = () => emojis[Math.floor(Math.random() * emojis.length)];
            
            $('#icon-picker-btn').addEventListener('click', () => {
                $('#reg-icon').value = getRandomEmoji();
            });
            
            // 入力チェック
            const checkRegForm = () => {
                const name = $('#reg-name').value.trim();
                const grade = $('#reg-grade').value;
                $('#reg-complete-btn').disabled = !(name && grade);
            };
            $('#reg-name').addEventListener('input', checkRegForm);
            $('#reg-grade').addEventListener('change', checkRegForm);

            $('#reg-complete-btn').addEventListener('click', () => {
                // 一時保存してチュートリアルへ
                state.user.name = $('#reg-name').value.trim();
                state.user.icon = $('#reg-icon').value;
                state.user.grade = $('#reg-grade').value;
                
                $('#registration-screen').classList.add('hidden');
                $('#tutorial-screen').classList.remove('hidden');
                updateTutorialSlide(0);
            });

            $('#reg-back-btn').addEventListener('click', () => {
                $('#registration-screen').classList.add('hidden');
                $('#welcome-screen').classList.remove('hidden');
            });

            // チュートリアル
            let tutorialIndex = 0;
            const tutorialSlides = 3; 
            
            function updateTutorialSlide(index) {
                tutorialIndex = index;
                const track = document.getElementById('tutorial-track');
                track.style.transform = `translateX(-${index * 100}%)`;
                
                // ドット更新
                const dots = document.getElementById('tutorial-dots').children;
                Array.from(dots).forEach((dot, i) => {
                    dot.className = `w-2 h-2 rounded-full ${i === index ? 'bg-white' : 'bg-gray-600'}`;
                });
                
                const btn = $('#tutorial-next-btn');
                btn.textContent = index === tutorialSlides - 1 ? '始める' : '次へ';
            }

            $('#tutorial-next-btn').addEventListener('click', () => {
                if (tutorialIndex < tutorialSlides - 1) {
                    updateTutorialSlide(tutorialIndex + 1);
                } else {
                    // 完了処理
                    state.user.isRegistered = true;
                    saveState();
                    
                    $('#tutorial-screen').classList.add('hidden');
                    $('#app-container').classList.remove('hidden');
                    
                    // ホーム画面を更新
                    renderEngine.pages['home-page']();
                    showToast(`ようこそ、${state.user.name}さん！`);
                }
            });

            // プロフィール編集・閲覧モーダル
            function openProfileModal() {
                const modal = $('#profile-modal');
                // 現在の値を入れる
                $('#edit-profile-icon').value = state.user.icon;
                $('#edit-profile-name').value = state.user.name;
                
                // 学年のオプションをコピー
                const gradeSelect = $('#edit-profile-grade');
                gradeSelect.innerHTML = $('#reg-grade').innerHTML;
                gradeSelect.value = state.user.grade;
                
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
            }
            
            $('.close-profile-btn').addEventListener('click', () => {
                $('#profile-modal').style.display = 'none';
            });
            
            $('#edit-icon-random-btn').addEventListener('click', () => {
                $('#edit-profile-icon').value = getRandomEmoji();
            });

            $('#save-profile-btn').addEventListener('click', () => {
                state.user.icon = $('#edit-profile-icon').value;
                state.user.name = $('#edit-profile-name').value;
                state.user.grade = $('#edit-profile-grade').value;
                saveState();
                
                // 設定画面を再描画
                renderEngine.pages['settings-page']();
                $('#profile-modal').style.display = 'none';
                showToast('プロフィールを更新しました');
            });
            
            $('#open-migration-menu-btn').addEventListener('click', () => {
                 openMigrationModal(false);
            });


            // ==========================================
            // ▼▼▼ PeerJS データ移行ロジック ▼▼▼
            // ==========================================
            
            let peer = null;
            let conn = null;

            // 【修正】引数 autoReceive を追加
            function openMigrationModal(autoReceive = false) {
                $('#migration-modal').classList.remove('hidden');
                $('#migration-modal').style.display = 'flex';
                
                // 一度全てのビューを隠す
                $('#migration-step-1').classList.add('hidden');
                $('#migration-sender-view').classList.add('hidden');
                $('#migration-receiver-view').classList.add('hidden');
            
                if (autoReceive) {
                    // ようこそ画面からの場合：いきなり「受け取る」モードにする
                    $('#migration-receiver-view').classList.remove('hidden');
                    initPeerReceiver(); // 受信待機を開始
                } else {
                    // 設定画面からの場合：選択肢を表示
                    $('#migration-step-1').classList.remove('hidden');
                }
                
                lucide.createIcons();
            }

            $('#close-migration-btn').addEventListener('click', () => {
                $('#migration-modal').style.display = 'none';
                if(peer) { peer.destroy(); peer = null; }
            });

            // 送る側 (古いスマホ)
            $('#migration-mode-send').addEventListener('click', () => {
                $('#migration-step-1').classList.add('hidden');
                $('#migration-sender-view').classList.remove('hidden');
                
                // Peer初期化
                initPeerSender();
            });

            // 受け取る側 (新しいスマホ)
            $('#migration-mode-receive').addEventListener('click', () => {
                $('#migration-step-1').classList.add('hidden');
                $('#migration-receiver-view').classList.remove('hidden');
                
                // Peer初期化
                initPeerReceiver();
            });

            function initPeerSender() {
                // 送信側はID指定せずにPeer作成 (IDはなんでもいい)
                peer = new Peer(); 
                
                peer.on('open', (id) => {
                    // 送信側は自分のIDを表示する必要はないが、接続ボタン待機
                    $('#migration-status-send').textContent = "準備完了。相手のIDを入力してください。";
                });
                
                peer.on('error', (err) => {
                    console.error(err);
                    $('#migration-status-send').textContent = "エラーが発生しました: " + err.type;
                });
            }
            
            $('#migration-connect-btn').addEventListener('click', () => {
                const targetId = $('#migration-target-id').value.trim().toUpperCase();
                if(!targetId) return;
                
                $('#migration-status-send').textContent = "接続中...";
                
                conn = peer.connect(targetId);
                
                conn.on('open', () => {
                    const isConfirmed = confirm("【重要】\nデータを移行しますか？\n\n「OK」を押すとデータが送信され、この端末のデータは削除（ログアウト）されます。");
            
                    if (isConfirmed) {
                        $('#migration-status-send').textContent = "接続成功！データを送信しています...";
                        
                        // 全データを送信
                        const dataToSend = JSON.stringify(state);
                        conn.send(dataToSend);
                        
                        setTimeout(() => {
                            alert('データの送信が完了しました。\nこの端末のデータはリセットされます。');
                            // ログアウト処理 (ローカルデータ消去)
                            localStorage.removeItem('quizAppUltimateV8');
                            location.reload();
                        }, 1000);
                    } else {
                        // キャンセルした場合
                        $('#migration-status-send').textContent = "キャンセルされました。";
                        conn.close(); // 接続を切る
                    }
                });
                
                conn.on('error', (err) => {
                     $('#migration-status-send').textContent = "送信エラー";
                });
            });

            function initPeerReceiver() {
                // IDを生成 (ランダムな4桁の英数字などで簡易化)
                // PeerJS Serverのデフォルトを使う場合、ID重複の可能性があるので少し長めに
                const myPeerId = Math.random().toString(36).substring(2, 6).toUpperCase(); 
                
                peer = new Peer(myPeerId);
                
                peer.on('open', (id) => {
                    $('#migration-my-id').textContent = id;
                    $('#migration-status-receive').textContent = "このIDを古いスマホに入力してください";
                });
                
                peer.on('connection', (c) => {
                    // 相手から接続された
                    $('#migration-status-receive').textContent = "接続されました！データ受信中...";
                    
                    c.on('data', (data) => {
                        console.log('Received', data);
                        try {
                            // 受信データの検証（簡易）
                            const receivedState = JSON.parse(data);
                            if(receivedState.profile && receivedState.user) {
                                // 保存してリロード
                                localStorage.setItem('quizAppUltimateV8', data);
                                alert('データの引き継ぎが完了しました！\nアプリを再起動します。');
                                location.reload();
                            }
                        } catch(e) {
                            console.error(e);
                            alert('データの破損などのエラーが発生しました');
                        }
                    });
                });
                
                peer.on('error', (err) => {
                     // IDが被った場合などはリトライが必要
                     if(err.type === 'unavailable-id') {
                         initPeerReceiver(); // ID変えてリトライ
                     } else {
                         $('#migration-status-receive').textContent = "エラー: " + err.type;
                     }
                });
            }

            // ==========================================
            // ▲▲▲ 新規追加ロジック終了 ▲▲▲
            // ==========================================

            // ★新規追加: クエストの復元チェック関数
            const checkQuestResume = () => {
                if (state.savedQuest && state.savedQuest.active) {
                    // モーダルを表示
                    const modal = $('#resume-quest-modal');
                    modal.classList.remove('hidden');
                    
                    // 「再開する」ボタン
                    $('#resume-quest-yes-btn').onclick = () => {
                        modal.classList.add('hidden');
                        resumeQuestProcess();
                    };

                    // 「終了してホームへ」ボタン
                    $('#resume-quest-no-btn').onclick = () => {
                        modal.classList.add('hidden');

                        // ★追加: 中断としてログに記録する処理
                        const saved = state.savedQuest;
                        const currentStep = saved.plan[saved.currentIndex];
                        
                        // 実際に経過した時間（開始〜現在）を計算
                        const now = Date.now();
                        const elapsedSeconds = Math.floor((now - saved.startTime) / 1000);
                        
                        // もしステップの予定時間を超えていたら、予定時間分だけ記録（完了扱い）
                        // 超えていなければ、経過時間分だけ記録（中断扱い）
                        const actualDuration = Math.min(elapsedSeconds, currentStep.duration);

                        if (currentStep.type === 'section' && actualDuration > 0) {
                            const statusText = (elapsedSeconds >= currentStep.duration) ? '(不在中完了)' : '(中断)';
                            recordSession(currentStep.text + statusText, actualDuration);
                            
                            // 少しだけLPをあげる（任意）
                            if (actualDuration > 60) {
                                addLP(Math.floor(actualDuration / 60), 'クエスト終了');
                            }
                        }
                        
                        state.savedQuest = null;
                        saveState();
                        showToast('クエストを破棄しました');
                    };
                }
            };

            // ★新規追加: クエスト復元実行プロセス
            const resumeQuestProcess = () => {
                const saved = state.savedQuest;
                quest.plan = saved.plan;
                quest.currentIndex = saved.currentIndex;
                quest.active = true;
                updateBackgrounds();

                // UI切り替え
                $('header').style.display = 'none';
                $('nav').style.display = 'none';
                $('#mini-timer-container').classList.remove('visible');
                $('#quest-active-screen').style.display = 'flex';
                document.body.style.overflow = 'hidden';

                const currentStep = quest.plan[quest.currentIndex];
                
                // 経過時間を計算
                const now = Date.now();
                const elapsedSinceStart = Math.floor((now - saved.startTime) / 1000);
                const remaining = currentStep.duration - elapsedSinceStart;

                if (remaining <= 0) {
                    // 裏で終わっていた場合
                    showToast('閉じている間にこのステップは終了しました。');
                    // ログ記録などは省略して、強制的に次へ進めるか、完了扱いにする
                    // ここではシンプルに「完了」として次へ
                    if (currentStep.type === 'section') {
                        // ログだけ記録しておく
                        recordSession(currentStep.text + '(中断)', currentStep.duration);
                        state.focus.totalTime += currentStep.duration;
                        addLP(Math.floor(currentStep.duration / 60), 'クエストセクション');
                        saveState();
                    }
                    // 次へ
                    runNextQuestStep();
                } else {
                    // まだ続いている場合 -> そのステップを途中から再開
                    // executeQuestStepを呼ぶとタイマーがリセットされるので、
                    // 手動でUIセットアップして startQuestTimer を呼ぶ
                    setupResumedStep(currentStep, remaining);
                }
            };

            // ★新規追加: 途中からステップを開始するヘルパー
            const setupResumedStep = (step, timeLeft) => {
                cancelQuestAlarm(); // 念のため

                if (step.type === 'section') {
                    playBGM();
                    questSectionView.style.display = 'flex';
                    questBreakView.style.display = 'none';
                    $('#break-settings-btn').classList.add('hidden');
                    questSectionTitle.textContent = step.text;
                    const totalSections = quest.plan.filter(p => p.type === 'section').length;
                    const currentSectionNumber = quest.plan.slice(0, quest.currentIndex + 1).filter(p => p.type === 'section').length;
                    questProgressEl.textContent = `${currentSectionNumber} / ${totalSections}`;
                    
                    // タイマー再開
                    startQuestTimer(
                        timeLeft, // 残り時間で開始
                        (t) => { questTimerEl.textContent = formatTime(t); },
                        () => {
                            // 終了時の処理（executeQuestStepの中身と同じロジックが必要）
                            // 簡略化のため共通部分を関数化するか、ここにコピー
                            const elapsed = step.duration; // 満了扱い
                            recordSession(step.text, elapsed);
                            addLP(Math.floor(elapsed / 60), 'クエストセクション');
                            state.focus.totalTime += elapsed;
                            if (step.originalTaskId) {
                                const tIndex = state.tasks.findIndex(t => t.id === parseInt(step.originalTaskId));
                                if (tIndex !== -1) state.tasks[tIndex].completed = true;
                            }
                            saveState();
                            showToast('お疲れ様でした！');
                            runNextQuestStep();
                        }
                    );
                } else {
                    // 休憩の場合
                    pauseBGM();
                    questSectionView.style.display = 'none';
                    questBreakView.style.display = 'flex';
                    $('#break-settings-btn').classList.remove('hidden');
                    renderBreakIcons();
                    
                    startQuestTimer(
                        timeLeft,
                        (t) => { breakTimerEl.textContent = formatTime(t); },
                        () => {
                            showToast('休憩が終わりました。');
                            closeIframe();
                            runNextQuestStep();
                        }
                    );
                }
                lucide.createIcons();
            };

            const init = () => {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('sw.js')
                        .then(registration => console.log('Service Worker登録成功:', registration))
                        .catch(error => console.log('Service Worker登録失敗:', error));
                }
                // ★追加: 画面の他の場所をタップしたら開いているスワイプメニューを閉じる処理
                document.addEventListener('touchstart', (e) => {
                    // タップされた要素が「開いているスワイプコンテナ」の内部でなければ閉じる
                    const openContainers = document.querySelectorAll('.swipe-container.swiped-open');
                    
                    openContainers.forEach(container => {
                        // コンテナ自身やその子要素をクリックした場合は何もしない（ボタン操作などのため）
                        if (container.contains(e.target)) return;

                        // それ以外（外側）をタップした場合は閉じる
                        const content = container.querySelector('.swipe-content');
                        if (content) {
                            content.style.transform = 'translateX(0px)';
                            container.classList.remove('swiped-open');
                        }
                    });
                }, { passive: true });
                
                loadState();

                syncGamesToBreakIcons();

                // 1. 新しいDOM要素を変数に割り当て
                homeTaskListEl = $('#home-task-list');
                newTaskInput = $('#new-task-input');
                newTaskNumberEl = $('#new-task-number');
                
                // ページ描画の前にタイマーの状態を復元・設定する
                restoreFocusState();
                checkQuestResume();  // ★追加: クエストの復元チェック
                
                // 全てのページを描画
                renderEngine.renderAll();
                
                // 2. Sortable.js の初期化 (今日の予定)
                if (homeTaskListEl) {
                    Sortable.create(homeTaskListEl, {
                        handle: '.task-handle', 
                        animation: 150,
                        ghostClass: 'sortable-ghost',
                        delay: 200, // ★重要: 200ms長押ししないとドラッグ開始しない
                        delayOnTouchOnly: true, // タッチ操作の時だけ遅延させる（マウスは即時）
                        touchStartThreshold: 5, // 5px以上動いたらタップではなくドラッグ判定（誤動作防止）
                        filter: '.swiped-open, .is-swiping, .swipe-deleting', // ★追加: これらが付いている要素は並び替え不可
                        onEnd: (evt) => { /* 中身は変更なし */
                            const item = state.tasks.splice(evt.oldIndex, 1)[0];
                            state.tasks.splice(evt.newIndex, 0, item);
                            saveState();
                            renderHomeTasks(); 
                        }
                    });

                    // 3. タスク削除のイベントリスナー (イベント委任)
                    homeTaskListEl.addEventListener('click', (e) => {
                        const deleteBtn = e.target.closest('.delete-task-btn');
                        if (deleteBtn) {
                            const taskItem = deleteBtn.closest('.task-item');
                            const taskId = parseInt(taskItem.dataset.id);
                            state.tasks = state.tasks.filter(t => t.id !== taskId);
                            saveState();
                            renderHomeTasks();
                        }
                    });
                }

                // 4. 新規タスク追加 (Enterキー)
                if (newTaskInput) {
                    newTaskInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter' && e.target.value.trim() !== '') {
                            state.tasks.push({ id: Date.now(), text: e.target.value.trim() });
                            e.target.value = '';
                            saveState();
                            renderHomeTasks();
                        }
                    });
                }

                 // Sortable.js の初期化 (クエストプラン)
                    if (questPlanListEl) { // questPlanListEl はグローバルスコープで定義済み
                        Sortable.create(questPlanListEl, {
                            handle: '.quest-handle', // クエストのハンドル
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            delay: 200, // ★追加
                            delayOnTouchOnly: true, // ★追加
                            touchStartThreshold: 5, // ★追加
                            filter: '.swiped-open, .is-swiping, .swipe-deleting', // ★追加
                            onEnd: (evt) => {
                                // quest.plan 配列を並び替え
                                // (quest.plan は state に保存されない一時的なもの)
                                const item = quest.plan.splice(evt.oldIndex, 1)[0];
                                quest.plan.splice(evt.newIndex, 0, item);
                                renderQuestPlan(); // 番号を振り直すために再描画
                            }
                        });
                    }
                
                // 5. 「今日の予定」読み込みボタン
                const loadTasksBtn = $('#load-tasks-btn');
                if (loadTasksBtn) {
                    loadTasksBtn.addEventListener('click', () => {
                        // 完了していないタスクのみをフィルタリングして読み込む
                        const activeTasks = state.tasks.filter(t => !t.completed);

                        if (activeTasks.length === 0) {
                            showToast('「今日の予定」に未完了のタスクがありません。');
                            // quest.plan = []; // 既存のプランを消したくない場合はコメントアウト
                        } else {
                            // state.tasks を quest.plan にマッピング
                            quest.plan = activeTasks.map(task => ({
                                id: Date.now() + Math.random(),
                                type: 'section',
                                text: task.text,
                                duration: 25 * 60,
                                originalTaskId: task.id
                            }));
                            showToast(`${activeTasks.length} 件の未完了タスクを読み込みました。`);
                        }
                        renderQuestPlan();
                    });
                }
                
                // 最後に外観を更新
                $('#background-scope-toggle').checked = state.settings.backgroundScopeGlobal;
                updateAppearance();

                checkUserRegistration();
                
                // ▼▼▼ 変更（initの最後にlucideを1回実行） ▼▼▼
                lucide.createIcons();
                    setTimeout(() => {
                        // もし未登録なら、スプラッシュが消える直前に「ようこそ画面」を裏で表示状態にする
                        if (!state.user.isRegistered) {
                            $('#welcome-screen').classList.remove('hidden');
                        }
                    
                        const splash = document.getElementById('splash-screen');
                        if (splash) {
                            // フェードアウト開始
                            splash.classList.add('opacity-0');
                            
                            // アニメーション完了後に非表示
                            setTimeout(() => {
                                splash.style.display = 'none';
                            }, 500);
                        }
                    }, 1500); // 1.5秒待ってからフェードアウト開始
            };
            const renderPointModalContent = () => {
                // 1. テーマ
                const themeContainer = $('#modal-theme-selector');
                themeContainer.innerHTML = Object.entries(initialData.themes).map(([id, theme]) => {
                    const isUnlocked = state.profile.unlockedThemes.includes(id);
                    // (既存の表示ロジック...)
                    if (isUnlocked) {
                         return `<div class="text-center"><button class="theme-btn w-12 h-12 rounded-full border-4 ${state.profile.activeTheme === id ? 'border-blue-500' : 'border-transparent'} relative" style="background-color: ${theme.color}" data-theme="${id}"><div class="absolute inset-0 flex items-center justify-center rounded-full"><i data-lucide="check" class="w-6 h-6 text-white"></i></div></button><p class="text-xs mt-1">${theme.name}</p></div>`;
                    } else {
                        return `<div class="text-center"><button class="theme-btn w-12 h-12 rounded-full border-4 border-transparent relative" style="background-color: ${theme.color}" data-theme="${id}"><div class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center rounded-full text-white"><i data-lucide="lock" class="w-5 h-5"></i><span class="text-[10px] font-bold">${theme.cost}</span></div></button><p class="text-xs mt-1">${theme.name}</p></div>`;
                    }
                }).join('');

                // 2. 壁紙
                const backgroundContainer = $('#modal-background-selector');
                backgroundContainer.innerHTML = Object.entries(initialData.backgrounds).map(([id, bg]) => {
                    const isUnlocked = state.profile.unlockedBackgrounds.includes(id);
                    const style = bg.url ? `background-image: url(${bg.url})` : 'background-color: #6b7280;';
                    // (既存の表示ロジック...)
                     if (isUnlocked) {
                        return `<div class="text-center"><button class="background-btn w-full h-20 rounded-lg border-4 ${state.profile.activeBackground === id ? 'border-blue-500' : 'border-transparent'} relative bg-cover bg-center" style="${style}" data-bg="${id}"><div class="absolute inset-0 flex items-center justify-center rounded-md"><i data-lucide="check" class="w-8 h-8 text-white"></i></div></button><p class="text-xs mt-1">${bg.name}</p></div>`;
                    } else {
                         return `<div class="text-center"><button class="background-btn w-full h-20 rounded-lg border-4 border-transparent relative bg-cover bg-center" style="${style}" data-bg="${id}"><div class="absolute inset-0 bg-black/60 flex flex-col items-center justify-center rounded-md text-white"><i data-lucide="lock" class="w-6 h-6"></i><span class="text-sm font-bold">${bg.cost}</span></div></button><p class="text-xs mt-1">${bg.name}</p></div>`;
                    }
                }).join('');

                // ▼▼▼ 【追加】ゲーム＆音楽セクションの描画（マイステータスモーダル内に動的に追加） ▼▼▼
                
                // モーダル内のコンテンツコンテナを取得（なければ既存の場所に追加）
                const container = $('#point-details-modal .space-y-6');
                
                // 既存のゲーム・音楽セクションがあれば削除（二重描画防止）
                const existingGameSec = container.querySelector('#modal-game-section');
                if(existingGameSec) existingGameSec.remove();
                const existingMusicSec = container.querySelector('#modal-music-section');
                if(existingMusicSec) existingMusicSec.remove();

                // ゲームセクション作成
                const gameHtml = Object.entries(initialData.games).map(([id, game]) => {
                    const isUnlocked = state.profile.unlockedGames.includes(id);
                    return isUnlocked 
                        ? `<div class="text-center opacity-50"><div class="w-16 h-16 mx-auto bg-gray-200 dark:bg-gray-600 rounded-lg flex items-center justify-center"><i data-lucide="check" class="w-8 h-8"></i></div><p class="text-xs mt-1">${game.name}</p></div>`
                        : `<div class="text-center cursor-pointer game-purchase-btn" data-id="${id}"><div class="w-16 h-16 mx-auto bg-gray-200 dark:bg-gray-600 rounded-lg flex flex-col items-center justify-center relative hover:bg-gray-300 dark:hover:bg-gray-500 transition"><i data-lucide="${game.icon}" class="w-6 h-6 mb-1"></i><span class="text-xs font-bold">${game.cost} LP</span></div><p class="text-xs mt-1">${game.name}</p></div>`;
                }).join('');

                const gameSection = document.createElement('div');
                gameSection.id = 'modal-game-section';
                gameSection.innerHTML = `<h3 class="font-semibold mb-2">ミニゲーム</h3><div class="grid grid-cols-4 gap-4">${gameHtml || '<p class="text-sm text-gray-400">アイテムがありません</p>'}</div>`;
                container.appendChild(gameSection);

                // 音楽セクション作成
                const musicHtml = Object.entries(initialData.music).map(([id, music]) => {
                    const isUnlocked = state.profile.unlockedMusic.includes(id);
                    return isUnlocked
                        ? `<div class="text-center opacity-50"><div class="w-16 h-16 mx-auto bg-gray-200 dark:bg-gray-600 rounded-lg flex items-center justify-center"><i data-lucide="check" class="w-8 h-8"></i></div><p class="text-xs mt-1">${music.name}</p></div>`
                        : `<div class="text-center cursor-pointer music-purchase-btn" data-id="${id}"><div class="w-16 h-16 mx-auto bg-gray-200 dark:bg-gray-600 rounded-lg flex flex-col items-center justify-center relative hover:bg-gray-300 dark:hover:bg-gray-500 transition"><i data-lucide="music" class="w-6 h-6 mb-1"></i><span class="text-xs font-bold">${music.cost} LP</span></div><p class="text-xs mt-1">${music.name}</p></div>`;
                }).join('');

                const musicSection = document.createElement('div');
                musicSection.id = 'modal-music-section';
                musicSection.innerHTML = `<h3 class="font-semibold mb-2">BGM</h3><div class="grid grid-cols-4 gap-4">${musicHtml || '<p class="text-sm text-gray-400">アイテムがありません</p>'}</div>`;
                container.appendChild(musicSection);

                // アイコン更新とイベントリスナー再設定
                lucide.createIcons();
                
                // 購入ボタンのリスナー設定
                gameSection.querySelectorAll('.game-purchase-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.dataset.id;
                        const item = initialData.games[id];
                        
                        $('#game-purchase-title').textContent = item.name; // 「〜を交換しますか？」は削除してシンプルに
                        $('#game-purchase-cost').textContent = `必要ポイント: ${item.cost} LP`;
                        
                        // ★プレビュー生成
                        renderGamePreviews(item);
                        
                        const confirmBtn = $('#game-purchase-confirm');
                        confirmBtn.dataset.itemId = id;
                        confirmBtn.dataset.itemType = 'game';
                        confirmBtn.disabled = state.profile.lp < item.cost;
                        
                        lucide.createIcons(); // プレビュー内のアイコン描画
                        $('#game-purchase-modal').style.display = 'flex';
                    });
                });

                musicSection.querySelectorAll('.music-purchase-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const id = btn.dataset.id;
                        const item = initialData.music[id];
                        
                        $('#music-purchase-title').textContent = item.name;
                        $('#music-purchase-cost').textContent = `必要ポイント: ${item.cost} LP`;
                        
                        // ★試聴ボタンの設定
                        const previewBtn = $('#music-preview-btn');
                        // 古いイベントリスナーを削除するためにクローンして置換（簡易的な方法）
                        const newPreviewBtn = previewBtn.cloneNode(true);
                        previewBtn.parentNode.replaceChild(newPreviewBtn, previewBtn);
                        
                        newPreviewBtn.addEventListener('click', (e) => {
                            // ▼修正: アイコンではなくボタン要素そのものを渡す
                            toggleMusicPreview(item.url, newPreviewBtn);
                        });
                
                        const confirmBtn = $('#music-purchase-confirm');
                        confirmBtn.dataset.itemId = id;
                        confirmBtn.dataset.itemType = 'music';
                        confirmBtn.disabled = state.profile.lp < item.cost;
                        
                        $('#music-purchase-modal').style.display = 'flex';
                        lucide.createIcons();
                    });
                });
            };

        /* ▼▼▼ 追加機能用関数 ▼▼▼ */
        
        // ゲームプレビュー（画像・動画）を生成する関数
        const renderGamePreviews = (game) => {
            const container = $('#game-preview-container');
            container.innerHTML = ''; // クリア
        
            if (!game.previews || game.previews.length === 0) {
                // プレビューがない場合のダミー
                container.innerHTML = `
                    <div class="preview-item">
                        <div class="flex flex-col items-center text-gray-400">
                            <i data-lucide="image-off" class="w-12 h-12 mb-2"></i>
                            <span>No Preview</span>
                        </div>
                    </div>`;
                return;
            }
        
            game.previews.forEach(url => {
                const item = document.createElement('div');
                item.className = 'preview-item';
                
                // 拡張子で画像か動画か簡易判定
                const isVideo = url.endsWith('.mp4') || url.endsWith('.webm');
                
                if (isVideo) {
                    item.innerHTML = `<video src="${url}" controls playsinline muted class="pointer-events-auto"></video>`;
                } else {
                    item.innerHTML = `<img src="${url}" alt="preview">`;
                }
                container.appendChild(item);
            });
        };
        
        // BGM試聴の再生・停止制御
        const toggleMusicPreview = (url, btnElement) => {
            // すでに再生中で、かつ同じURLなら「停止」とみなす
            if (!previewAudio.paused && previewAudio.src === url) {
                stopMusicPreview();
                return;
            }

            // 別の曲を再生する場合、または新規再生の場合
            // まず現在再生中のものを完全に停止・リセットする
            stopMusicPreview();

            // 新しく再生
            previewAudio.src = url;
            previewAudio.volume = 0.5;
            
            previewAudio.play().then(() => {
                // ボタンのアイコンを「停止(square)」に変更
                if (btnElement) {
                    btnElement.innerHTML = '<i data-lucide="square" class="w-5 h-5 fill-current"></i>';
                    btnElement.classList.add('playing-icon'); // アニメーション用クラス付与
                    
                    // アイコン再生成
                    lucide.createIcons({ root: btnElement });
                }
                
                // 30秒後に自動停止
                previewTimeout = setTimeout(() => {
                    stopMusicPreview();
                }, 30000); 

            }).catch(e => console.error("試聴エラー", e));
        };
        
        const stopMusicPreview = () => {
            previewAudio.pause();
            previewAudio.currentTime = 0;
            if (previewTimeout) clearTimeout(previewTimeout);
            
            // ★重要: ページ内のすべての「再生中」になっているボタンを元に戻す

            // 1. プレイリスト内のボタン(.preview-bgm-btn)のリセット
            document.querySelectorAll('.preview-bgm-btn').forEach(btn => {
                 btn.innerHTML = '<i data-lucide="play-circle" class="w-5 h-5"></i>';
                 btn.classList.remove('playing-icon');
            });
            
            // 2. モーダル内のボタン(#music-preview-btn)のリセット
            const modalBtn = document.getElementById('music-preview-btn');
            if (modalBtn) {
                modalBtn.innerHTML = '<i data-lucide="play" class="w-6 h-6 fill-current"></i>';
                modalBtn.classList.remove('playing-icon');
            }
            
            lucide.createIcons();
        };    
        
            
        // --- 購入モーダル関連のボタン ---
        $('#theme-purchase-confirm').addEventListener('click', handlePurchase);
        $('#theme-purchase-cancel').addEventListener('click', () => {
            $('#theme-purchase-modal').style.display = 'none';
        });

        $('#background-purchase-confirm').addEventListener('click', handlePurchase);
        $('#background-purchase-cancel').addEventListener('click', () => {
            $('#background-purchase-modal').style.display = 'none';
        });

        // --- ポイント詳細モーダルを閉じるボタン ---
        $('#close-point-modal-btn').addEventListener('click', () => {
            $('#point-details-modal').style.display = 'none';
        });

        // --- カウントダウンモーダル関連のボタン ---
        $('#add-countdown-btn').addEventListener('click', () => openCountdownModal());
        $('#countdown-save-btn').addEventListener('click', saveCountdown);
        $('#countdown-cancel-btn').addEventListener('click', () => {
            $('#countdown-modal').style.display = 'none';
        });
        $('#countdown-delete-btn').addEventListener('click', deleteCountdown);

        // --- ゲーム・音楽購入モーダル関連のボタン ---
        $('#game-purchase-confirm').addEventListener('click', handlePurchase);
        $('#game-purchase-cancel').addEventListener('click', () => { $('#game-purchase-modal').style.display = 'none'; });
        $('#music-purchase-confirm').addEventListener('click', handlePurchase);
        $('#music-purchase-cancel').addEventListener('click', () => { $('#music-purchase-modal').style.display = 'none'; });
        $('#music-purchase-cancel').addEventListener('click', () => { 
            stopMusicPreview(); // ★追加: 閉じたら停止
            $('#music-purchase-modal').style.display = 'none'; 
        });
            
            init();
        });
    </script>
</body>
</html>
